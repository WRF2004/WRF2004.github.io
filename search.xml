<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>BUAA-OS-lab2</title>
      <link href="/2024/03/25/BUAA-OS-lab2/"/>
      <url>/2024/03/25/BUAA-OS-lab2/</url>
      
        <content type="html"><![CDATA[<h3 id="BUAA-OS-Lab2"><a href="#BUAA-OS-Lab2" class="headerlink" title="BUAA_OS_Lab2"></a>BUAA_OS_Lab2</h3><h4 id="一、实验思考题"><a href="#一、实验思考题" class="headerlink" title="一、实验思考题"></a>一、实验思考题</h4><h5 id="Thinking-2-1"><a href="#Thinking-2-1" class="headerlink" title="Thinking 2.1"></a>Thinking 2.1</h5><blockquote><p> 请根据上述说明，回答问题：在编写的 C 程序中，指针变量中存储的地址被视为虚拟地址，还是物理地址？MIPS汇编程序中lw和sw指令使用的地址被视为虚拟 地址，还是物理地址？</p></blockquote><p>指针变量中存储的地址是虚拟地址，MIPS汇编程序中lw和sw指令使用的地址也是虚拟地址。</p><h5 id="Thinking-2-2"><a href="#Thinking-2-2" class="headerlink" title="Thinking 2.2"></a>Thinking 2.2</h5><blockquote><p>请思考下述两个问题： </p><ul><li>从可重用性的角度，阐述用宏来实现链表的好处。 </li><li>查看实验环境中的&#x2F;usr&#x2F;include&#x2F;sys&#x2F;queue.h，了解其中单向链表与循环链表的实现，比较它们与本实验中使用的双向链表，分析三者在插入与删除操作上的性能差异。</li></ul></blockquote><p>宏实现链表可以减少代码的复用，可重用性强，链表的插入和删除等操作使用宏可以保证这些操作都是一致的，从而减少了出错的可能性，可读性强，易于维护。</p><p>单向链表简单的插入与删除操作时间复杂度为O(1), 但是对任意的第n个元素的插入和删除操作需要遍历链表，时间复杂度为O(N); 双向链表对于任意第n个元素的插入与删除操作时间复杂度都为O(1); 循环链表中单向循环链表与单向链表一样，对任意的第n个元素的插入和删除操作时间复杂度为O(N)，双向循环链表对于任意第n个元素的插入与删除操作时间复杂度都为O(1)。</p><h5 id="Thinking-2-3"><a href="#Thinking-2-3" class="headerlink" title="Thinking 2.3"></a>Thinking 2.3</h5><blockquote><p>请阅读include&#x2F;queue.h以及include&#x2F;pmap.h,将Page_list的结构梳 理清楚，选择正确的展开结构。</p></blockquote><p>C</p><h5 id="Thinking-2-4"><a href="#Thinking-2-4" class="headerlink" title="Thinking 2.4"></a>Thinking 2.4</h5><blockquote><p>请思考下面两个问题：</p><ul><li>请阅读上面有关TLB的描述，从虚拟内存和多进程操作系统的实现角度，阐述ASID 的必要性。 </li><li>请阅读 MIPS 4Kc 文档《MIPS32® 4K™ Processor Core Family Software User’s Manual》的 Section 3.3.1 与 Section 3.4，结合 ASID 段的位数，说明 4Kc 中可容纳不同的地址空间的最大数量。</li></ul></blockquote><p>ASID用于区分不同的地址空间，同一虚拟地址在不同的地址空间中通常映射到不同的物理地址。ASID机制可以确保一个进程无法访问其他进程的内存区域，从而实现地址空间的隔离，起到内存保护的作用。同时，多进程操作系统通过ASID来管理和跟踪每个进程的虚拟地址空间。当进程切换时，操作系统可以根据ASID更新TLB的内容。</p><p>ASID段位数为8位，所以4Kc 中可容纳不同的地址空间的最大数量为256。</p><h5 id="Thinking-2-5"><a href="#Thinking-2-5" class="headerlink" title="Thinking 2.5"></a>Thinking 2.5</h5><blockquote><p>请回答下述三个问题： </p><ul><li>tlb_invalidate和tlb_out的调用关系？ </li><li>请用一句话概括tlb_invalidate的作用。 </li><li>逐行解释tlb_out中的汇编代码。</li></ul></blockquote><p>tlb_invalidate调用tlb_out; tlb_invalidate 函数实现删除特定虚拟地址在 TLB中的旧表项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;asm&#x2F;asm.h&gt;</span><br><span class="line"></span><br><span class="line">LEAF(tlb_out) </span><br><span class="line">.set noreorder</span><br><span class="line">mfc0    t0, CP0_ENTRYHI &#x2F;&#x2F;将当前的VPN和ASID存储到t0寄存器中，用于后续恢复CP0_ENTRYHI </span><br><span class="line">mtc0    a0, CP0_ENTRYHI &#x2F;&#x2F;将调用函数传入的旧表项的Key(由VPN和ASID组成)写进CP0_ENTRYHI </span><br><span class="line">nop</span><br><span class="line">&#x2F;* Step 1: Use &#39;tlbp&#39; to probe TLB entry *&#x2F;</span><br><span class="line">&#x2F;* Exercise 2.8: Your code here. (1&#x2F;2) *&#x2F;</span><br><span class="line">tlbp &#x2F;&#x2F;根据CP0_EntryHi中的Key查找TLB中对应的旧表项，将表项的索引存入CP0_Index。</span><br><span class="line">nop</span><br><span class="line">&#x2F;* Step 2: Fetch the probe result from CP0.Index *&#x2F;</span><br><span class="line">mfc0    t1, CP0_INDEX &#x2F;&#x2F;将CP0_Index存储t1寄存器。</span><br><span class="line">.set reorder</span><br><span class="line">bltz    t1, NO_SUCH_ENTRY &#x2F;&#x2F;如果t1寄存器中的值小于0（即TLB中不存在</span><br><span class="line">Key对应的表项），跳转到NO_SUCH_ENTRY标签处。</span><br><span class="line">.set noreorder</span><br><span class="line">&#x2F;&#x2F;如果t1寄存器中的值大于等于0（即TLB中存在Key对应的表项），我们向EntryHi和EntryLo0、EntryLo1中写入0</span><br><span class="line">mtc0    zero, CP0_ENTRYHI</span><br><span class="line">mtc0    zero, CP0_ENTRYLO0</span><br><span class="line">mtc0    zero, CP0_ENTRYLO1</span><br><span class="line">nop</span><br><span class="line">&#x2F;* Step 3: Use &#39;tlbwi&#39; to write CP0.EntryHi&#x2F;Lo into TLB at CP0.Index  *&#x2F;</span><br><span class="line">&#x2F;* Exercise 2.8: Your code here. (2&#x2F;2) *&#x2F;</span><br><span class="line">tlbwi   &#x2F;&#x2F;将EntryHi和EntryLo0、EntryLo1中的值写入索引指定的表项。此时旧表项的Key和Data被清零，实现将其无效化</span><br><span class="line">.set reorder</span><br><span class="line"></span><br><span class="line">NO_SUCH_ENTRY:</span><br><span class="line">mtc0    t0, CP0_ENTRYHI &#x2F;&#x2F;将原始的ENTRYHI寄存器的值（保存在t0中）恢复回ENTRYHI寄存器。</span><br><span class="line">j       ra &#x2F;&#x2F;函数结束并返回</span><br><span class="line">END(tlb_out)</span><br></pre></td></tr></table></figure><h5 id="Thinking-A-1"><a href="#Thinking-A-1" class="headerlink" title="Thinking A.1"></a>Thinking A.1</h5><blockquote><p>在现代的 64 位系统中，提供了 64 位的字长，但实际上不是 64 位页式存 储系统。假设在64位系统中采用三级页表机制，页面大小4KB。由于64位系统中字长为 8B，且页目录也占用一页，因此页目录中有512 个页目录项，因此每级页表都需要9位。 因此在64位系统下，总共需要3×9+12&#x3D;39位就可以实现三级页表机制，并不需要64 位。现考虑上述39位的三级页式存储系统，虚拟地址空间为512GB，若三级页表的基地 址为PTbase，请计算： </p><p>•三级页表页目录的基地址。 </p><p>•映射到页目录自身的页目录项（自映射）。</p></blockquote><p>三级页表页目录的基地址是(PTbase &gt;&gt; 30) &lt;&lt; 30; 映射到页目录自身的页目录项（自映射）为PTbase + ((PTbase &gt;&gt; 12) &lt;&lt; 3)  + ((((PTbase &gt;&gt; 12) &lt;&lt; 3) &gt;&gt; 12) &lt;&lt; 3) + ((((((PTbase &gt;&gt; 12) &lt;&lt; 3) &gt;&gt; 12) &lt;&lt; 3) &gt;&gt; 12) &lt;&lt; 3)</p><h5 id="Thinking-2-6"><a href="#Thinking-2-6" class="headerlink" title="Thinking 2.6"></a>Thinking 2.6</h5><blockquote><p>从下述三个问题中任选其一回答：</p><p>• 简单了解并叙述X86体系结构中的内存管理机制，比较X86和MIPS在内存管理上 的区别。<br>• 简单了解并叙述RISC-V 中的内存管理机制，比较RISC-V 与 MIPS 在内存管理上 的区别。 </p><p>• 简单了解并叙述LoongArch 中的内存管理机制，比较 LoongArch 与 MIPS 在内存 管理上的区别。</p></blockquote><p>X86 体系结构中的内存管理机制: </p><ul><li>通过分段将逻辑地址转换为线性地址，通过分页将线性地址转换为物理地址。</li><li>X86采用分段机制来管理内存。内存被划分为多个段，每个段都有起始地址和长度描述。CPU通过逻辑地址访问内存，这个逻辑地址包含段选择符和偏移量。</li><li>当CPU尝试访问某个内存位置时，它会使用段选择符在段描述符表中查找对应的段描述符，然后根据段描述符中的基地址和偏移量相加就是线性地址。</li><li>X86使用分页机制来进一步管理内存。内存被划分为固定大小的页面，每个页面都有一个唯一的物理地址。</li><li>操作系统创建全局描述符表和提供逻辑地址，之后的分段操作x86的CPU会自动完成，并找到对应的线性地址。</li><li>从线性地址到物理地址的转换是CPU自动完成的，转化时使用的Page Directory和Page Table等需要操作系统提供。</li></ul><p>X86和MIPS在内存管理上的区别：</p><ul><li>在TLB处理方面，当TLB不命中时（即TLB中没有缓存所需的虚拟地址到物理地址的映射关系），MIPS会触发一个异常（如TLB Refill异常），然后由内核的特定处理程序来处理这个异常并更新TLB。而X86则是由硬件的MMU（内存管理单元）直接处理不命中情况，它会使用页表来找到正确的物理地址，并更新TLB以便下次快速访问。</li><li>MIPS属于RISC（精简指令集计算机）架构，其指令集固定长度且数量有限，通常通过Load&#x2F;Store指令来访问内存。而X86则属于CISC（复杂指令集计算机）架构，其指令集更加丰富和复杂，包括多种直接操作内存的指令。</li><li>分页方式不同：一种MIPS系统内部只有一种分页方式，x86的CPU支持三种分页模式。</li><li>逻辑地址不同：MIPS地址空间32位，x86支持64位逻辑地址，同时提供转换为32位定址选项。</li></ul><h4 id="二、实验难点"><a href="#二、实验难点" class="headerlink" title="二、实验难点"></a>二、实验难点</h4><h5 id="mips-detect-memory-函数补全"><a href="#mips-detect-memory-函数补全" class="headerlink" title="mips_detect_memory 函数补全"></a>mips_detect_memory 函数补全</h5><p>总页数npage等于memsize除以单个页面的大小。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npage &#x3D; memsize &#x2F; PAGE_SIZE;</span><br></pre></td></tr></table></figure><h5 id="LIST-INSERT-AFTER函数"><a href="#LIST-INSERT-AFTER函数" class="headerlink" title="LIST_INSERT_AFTER函数"></a>LIST_INSERT_AFTER函数</h5><p> LIST_INSERT_AFTER的作用是将新加elm节点插入到链表现有listelm结点之后，我们需要利用已经定义的宏<strong>LIST_NEXT(elm, field)<strong>，按照</strong>LIST_INSERT_BEFORE</strong>的写法来完成函数。<strong>注意</strong>：宏定义函数每行需要用“\”进行链接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define LIST_NEXT(elm, field) ((elm)-&gt;field.le_next)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#define LIST_INSERT_BEFORE(listelm, elm, field)                                                    \</span><br><span class="line">do &#123;                                                                                       \</span><br><span class="line">(elm)-&gt;field.le_prev &#x3D; (listelm)-&gt;field.le_prev;                                   \</span><br><span class="line">LIST_NEXT((elm), field) &#x3D; (listelm);                                               \</span><br><span class="line">*(listelm)-&gt;field.le_prev &#x3D; (elm);                                                 \</span><br><span class="line">(listelm)-&gt;field.le_prev &#x3D; &amp;LIST_NEXT((elm), field);                               \</span><br><span class="line">&#125; while (0)</span><br></pre></td></tr></table></figure><p>根据注释的提示，我们第一步需要将<strong>listelm.next</strong>分配给<strong>elm.next</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LIST_NEXT((elm), field) &#x3D; LIST_NEXT((listelm), field); &#x2F;&#x2F; assign &#39;elm.next&#39; from &#39;listelm.next&#39;.</span><br></pre></td></tr></table></figure><p>第二步：如果<strong>listelm.next</strong>不为空，则将<strong>elm</strong>分配为<strong>listelm.next</strong>的前一个节点<strong>listelm.next.pre</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(LIST_NEXT((listelm), field)) &#123;   \</span><br><span class="line">*((LIST_NEXT((listelm), field))-&gt;field.le_prev) &#x3D; (elm);                   \</span><br><span class="line">(LIST_NEXT((listelm), field))-&gt;field.le_prev &#x3D; &amp;LIST_NEXT((elm), field);   \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步：将<strong>elm</strong>分配为<strong>listelm.next</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LIST_NEXT((listelm), field) &#x3D; (elm);</span><br></pre></td></tr></table></figure><p>第四步：将<strong>elm</strong>的前一个结点<strong>elm.pre</strong>置为<strong>listelm.next</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(elm)-&gt;field.le_prev &#x3D; &amp;LIST_NEXT((listelm), field);</span><br></pre></td></tr></table></figure><h5 id="page-init函数"><a href="#page-init函数" class="headerlink" title="page_init函数"></a>page_init函数</h5><p>需要利用<strong>LIST_INIT</strong>函数先初始化链表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define LIST_INIT(head)                                                                            \</span><br><span class="line">do &#123;                                                                                       \</span><br><span class="line">LIST_FIRST((head)) &#x3D; NULL;                                                         \</span><br><span class="line">&#125; while (0)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LIST_INIT(&amp;page_free_list);</span><br></pre></td></tr></table></figure><p>再利用<strong>ROUND</strong>函数将<strong>freemem</strong>与<strong>PAGE_SIZE</strong>大小对齐。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">freemem &#x3D; ROUND(freemem, PAGE_SIZE);</span><br></pre></td></tr></table></figure><p>接着将<strong>freemem</strong>以下的内存的标记为<strong>used</strong>表明已使用过，即<strong>pp_ref</strong>置为1。需要用的页表头指针<strong>pages</strong>，计算出使用过的空间的页面数量，用循环遍历的方法赋值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct Page *pp &#x3D; pages;</span><br><span class="line">u_long used &#x3D; freemem &amp; (0x80000000 - 1);</span><br><span class="line">int p1 &#x3D; used &#x2F; PAGE_SIZE;</span><br><span class="line">int i &#x3D; 0;</span><br><span class="line">for (i &#x3D; 0; i &lt; p1; i++) &#123;</span><br><span class="line">pp-&gt;pp_ref &#x3D; 1;</span><br><span class="line">pp++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后将其他内存标记为<strong>free</strong>，表示没使用过并使用LIST_INSERT_HEAD 将 其插入空闲链表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">while (i &lt; npage) &#123;</span><br><span class="line">pp-&gt;pp_ref &#x3D; 0;</span><br><span class="line">LIST_INSERT_HEAD(&amp;page_free_list, pp, pp_link);</span><br><span class="line">pp++;</span><br><span class="line">i++; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="page-alloc-函数"><a href="#page-alloc-函数" class="headerlink" title="page_alloc 函数"></a>page_alloc 函数</h5><p>从空闲空间中取一个页面，如果不成功，则返回错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (LIST_EMPTY(&amp;page_free_list)) &#123;</span><br><span class="line">return -E_NO_MEM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<strong>memset</strong>函数初始化这个页面，如果空闲链表有可用的页，取出链表头部的一页；初始化后，将该页对应的页 控制块的地址放到调用者指定的地方。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct Page *pp;</span><br><span class="line">pp &#x3D; LIST_FIRST(&amp;page_free_list);</span><br><span class="line">LIST_REMOVE(pp, pp_link);</span><br><span class="line">memset((void *)page2kva(pp), 0, PAGE_SIZE);</span><br><span class="line">*new &#x3D; pp;</span><br></pre></td></tr></table></figure><h5 id="page-free-函数"><a href="#page-free-函数" class="headerlink" title="page_free 函数"></a>page_free 函数</h5><p>使用链表宏LIST_INSERT_HEAD，将页结构体插入空闲页结构体链表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void page_free(struct Page *pp) &#123;</span><br><span class="line">assert(pp-&gt;pp_ref &#x3D;&#x3D; 0);</span><br><span class="line">&#x2F;* Just insert it into &#39;page_free_list&#39;. *&#x2F;</span><br><span class="line">&#x2F;* Exercise 2.5: Your code here. *&#x2F;</span><br><span class="line">LIST_INSERT_HEAD(&amp;page_free_list, pp, pp_link);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="pgdir-walk函数"><a href="#pgdir-walk函数" class="headerlink" title="pgdir_walk函数"></a>pgdir_walk函数</h5><p>该函数的作用是：给定一个虚拟地址，在给定的页目录中查找这个虚拟地址对应的页表项，将其地址写入<em>ppte。如果这一虚拟地址对应的二级页表存在，则设置</em>ppte为这一页表项的地址；如果这一虚拟地址对应的二级页表不存在（即这一虚拟地址对应的页目录项无效）， 则当create不为0时先创建二级页表再查找页表项，为0时则将*ppte设置为空指针。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pgdir_entryp &#x3D; &amp;pgdir[PDX(va)];</span><br><span class="line">if (!(*pgdir_entryp &amp; PTE_V)) &#123;</span><br><span class="line">if (create) &#123;</span><br><span class="line">if (page_alloc(&amp;pp) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">*pgdir_entryp &#x3D; page2pa(pp) | PTE_C_CACHEABLE | PTE_V;</span><br><span class="line">pp-&gt;pp_ref++;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return -E_NO_MEM;</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">*ppte &#x3D; NULL;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Pte *pgt &#x3D; (Pte*)KADDR(PTE_ADDR(*pgdir_entryp));</span><br><span class="line">*ppte &#x3D; &amp;pgt[PTX(va)];</span><br><span class="line">return 0;</span><br></pre></td></tr></table></figure><h5 id="page-insert函数"><a href="#page-insert函数" class="headerlink" title="page_insert函数"></a>page_insert函数</h5><p>但先要将TLB中缓存的页表项删掉，然后更新内存中的页表项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tlb_invalidate(asid, va);</span><br></pre></td></tr></table></figure><p>获得页表目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(pgdir_walk(pgdir, va, 1, &amp;pte) !&#x3D; 0) &#123;</span><br><span class="line">return -E_NO_MEM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入新的页。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*pte &#x3D; page2pa(pp) | PTE_V | perm | PTE_C_CACHEABLE;</span><br><span class="line">pp-&gt;pp_ref++;</span><br></pre></td></tr></table></figure><h5 id="kern-tlb-asm-S中的tlb-out函数"><a href="#kern-tlb-asm-S中的tlb-out函数" class="headerlink" title="kern&#x2F;tlb_asm.S中的tlb_out函数"></a>kern&#x2F;tlb_asm.S中的tlb_out函数</h5><p>需要在两个位置插入两条指令，其中一个位置为tlbp，另一个位置为tlbwi。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">LEAF(tlb_out)</span><br><span class="line">.set noreorder</span><br><span class="line">mfc0    t0, CP0_ENTRYHI</span><br><span class="line">mtc0    a0, CP0_ENTRYHI</span><br><span class="line">nop</span><br><span class="line">&#x2F;* Step 1: Use &#39;tlbp&#39; to probe TLB entry *&#x2F;</span><br><span class="line">&#x2F;* Exercise 2.8: Your code here. (1&#x2F;2) *&#x2F;</span><br><span class="line">tlbp</span><br><span class="line">nop</span><br><span class="line">&#x2F;* Step 2: Fetch the probe result from CP0.Index *&#x2F;</span><br><span class="line">mfc0    t1, CP0_INDEX</span><br><span class="line">.set reorder</span><br><span class="line">bltz    t1, NO_SUCH_ENTRY</span><br><span class="line">.set noreorder</span><br><span class="line">mtc0    zero, CP0_ENTRYHI</span><br><span class="line">mtc0    zero, CP0_ENTRYLO0</span><br><span class="line">mtc0    zero, CP0_ENTRYLO1</span><br><span class="line">nop</span><br><span class="line">&#x2F;* Step 3: Use &#39;tlbwi&#39; to write CP0.EntryHi&#x2F;Lo into TLB at CP0.Index  *&#x2F;</span><br><span class="line">&#x2F;* Exercise 2.8: Your code here. (2&#x2F;2) *&#x2F;</span><br><span class="line">tlbwi   </span><br><span class="line">.set reorder</span><br></pre></td></tr></table></figure><h5 id="kern-tlbex-c中的-do-tlb-refill函数"><a href="#kern-tlbex-c中的-do-tlb-refill函数" class="headerlink" title="kern&#x2F;tlbex.c中的_do_tlb_refill函数"></a>kern&#x2F;tlbex.c中的_do_tlb_refill函数</h5><p>根据Hints来写就行。</p><blockquote><p>&#x2F;* Hints:</p><p>   *  Invoke ‘page_lookup’ repeatedly in a loop to find the page table entry ‘*ppte’</p><p>   * associated with the virtual address ‘va’ in the current address space ‘cur_pgdir’.</p><ul><li></li></ul><p>   *  <strong>While</strong> ‘page_lookup’ returns ‘NULL’, indicating that the ‘*ppte’ could not be found,</p><p>   *  allocate a new page using ‘passive_alloc’ until ‘page_lookup’ succeeds.</p><p>   *&#x2F;</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while(1) &#123;</span><br><span class="line">if (page_lookup(cur_pgdir, va, &amp;ppte) &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">passive_alloc(va, cur_pgdir, asid);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="kern-tlb-asm-S中的do-tlb-refill函数"><a href="#kern-tlb-asm-S中的do-tlb-refill函数" class="headerlink" title="kern&#x2F;tlb_asm.S中的do_tlb_refill函数"></a>kern&#x2F;tlb_asm.S中的do_tlb_refill函数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Hint: use &#39;tlbwr&#39; to write CP0.EntryHi&#x2F;Lo into a random tlb entry. *&#x2F;</span><br><span class="line">&#x2F;* Exercise 2.10: Your code here. *&#x2F;</span><br><span class="line">tlbwr</span><br></pre></td></tr></table></figure><h4 id="三、实验体会"><a href="#三、实验体会" class="headerlink" title="三、实验体会"></a>三、实验体会</h4><p>本次实验总体而言难度很大，主要是因为教程晦涩难懂而且要补全的代码大多需要使用许多前面定义的宏或者函数，这导致在写的时候需要耗费大量时间去了解这个宏或函数的用法，同时也需要注意一些细节，容易在细节上出错。</p>]]></content>
      
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DeepLearning</title>
      <link href="/2024/03/17/DeepLearning/"/>
      <url>/2024/03/17/DeepLearning/</url>
      
        <content type="html"><![CDATA[<h3 id="DeepLearning"><a href="#DeepLearning" class="headerlink" title="DeepLearning"></a>DeepLearning</h3><h4 id="Logistic-Regression"><a href="#Logistic-Regression" class="headerlink" title="Logistic Regression"></a>Logistic Regression</h4><h5 id="Basic-function"><a href="#Basic-function" class="headerlink" title="Basic function:"></a>Basic function:</h5><p>$$<br>w,x \in R^{n_x},x&#x3D; \begin{pmatrix} x_1\ x_2\ x_3\ …\ x_{n_x}\end{pmatrix}, b \in R, \ \hat y&#x3D; \sigma(w^Tx+b),\hat y \in (0,1),\ \sigma(z)&#x3D;\frac{1}{1+e^{-z}} \<br>$$</p><h5 id="Loss-function"><a href="#Loss-function" class="headerlink" title="Loss function:"></a>Loss function:</h5><p>$$<br>L(\hat y, y)&#x3D;-[ y\log \hat y +( 1-y ) \log (1-\hat y)]<br>$$</p><h5 id="Cost-function"><a href="#Cost-function" class="headerlink" title="Cost function"></a>Cost function</h5><p>$$<br>J(w,b)&#x3D;\frac{1}{m}\sum _{i&#x3D;1}^{m}L(\hat y^{(i)}, y^{(i)})<br>$$</p><h4 id="Gradient-Descent"><a href="#Gradient-Descent" class="headerlink" title="Gradient Descent"></a>Gradient Descent</h4><p>$$<br>w:&#x3D;w-\alpha \frac{dJ(w)}{dw}\\alpha为learning Rate<br>$$</p><h4 id="Forward-Propagation"><a href="#Forward-Propagation" class="headerlink" title="Forward Propagation"></a>Forward Propagation</h4><p>$$<br>J(a,b,c)&#x3D;3(a+bc)\ u&#x3D;bc\v&#x3D;a+u\J&#x3D;3v<br>$$</p><h4 id="Backward-Propagation"><a href="#Backward-Propagation" class="headerlink" title="Backward Propagation"></a>Backward Propagation</h4><p>$$<br>\frac{dL}{d\hat y}&#x3D;-\frac{y}{\hat y}+\frac{1-y}{1-\hat y}\<br>\hat y&#x3D;\sigma (z)\<br>\frac{d\hat y}{dz}&#x3D;\hat y(1-\hat y)\<br>\frac{dL}{dz}&#x3D;\frac{dL}{d\hat y}\frac{d\hat y}{dz}&#x3D;\hat y-y\<br>\frac{dL}{dw}&#x3D;\frac{dL}{dz}\frac{dz}{dw}&#x3D;(\hat y-y)x\<br>\frac{dL}{db}&#x3D;\hat y-y<br>$$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def propagate(w, b, x, y):</span><br><span class="line">    m &#x3D; x.shape[1]</span><br><span class="line">    # w : (n * 1) x : (n * m) y : (1 * m)</span><br><span class="line">    z &#x3D; np.dot(w.T, x) + b</span><br><span class="line">    a &#x3D; sigmoid(z)</span><br><span class="line">    dw &#x3D; 1.0 &#x2F; m * np.dot(x, (a - y).T)</span><br><span class="line">    db &#x3D; 1.0 &#x2F; m * np.sum(a - y)</span><br><span class="line">    cost &#x3D; -1.0 &#x2F; m * np.sum(y * np.log(a) + (1 - y) * np.log(1 - a))</span><br><span class="line">    grads &#x3D; &#123;&quot;dw&quot;: dw,</span><br><span class="line">             &quot;db&quot;: db&#125;</span><br><span class="line">    return grads, cost</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def optimize(w, b, X, Y, num_iterations, learning_rate, print_cost &#x3D; False):</span><br><span class="line">    costs &#x3D; []</span><br><span class="line">    for i in range(num_iterations):</span><br><span class="line">        grad, cost &#x3D; propagate(w, b, X, Y)</span><br><span class="line">        dw &#x3D; grad[&quot;dw&quot;]</span><br><span class="line">        db &#x3D; grad[&quot;db&quot;]</span><br><span class="line">        w &#x3D; w - learning_rate * dw</span><br><span class="line">        b &#x3D; b - learning_rate * db</span><br><span class="line">        if i % 100 &#x3D;&#x3D; 0:</span><br><span class="line">            costs.append(cost)</span><br><span class="line">        if print_cost and i % 100 &#x3D;&#x3D; 0:</span><br><span class="line">            print (&quot;Cost after iteration %i: %f&quot; %(i, cost))</span><br><span class="line">    paras &#x3D; &#123;&quot;w&quot;: w,</span><br><span class="line">             &quot;b&quot;: b&#125;</span><br><span class="line">    grads &#x3D; &#123;&quot;dw&quot;: dw,</span><br><span class="line">             &quot;db&quot;: db&#125;</span><br><span class="line">    return paras, grads, costs</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def predict(w, b, X):</span><br><span class="line">    m &#x3D; X.shape[1]</span><br><span class="line">    Y_prediction &#x3D; np.zeros((1,m))</span><br><span class="line">    w &#x3D; w.reshape(X.shape[0], 1)</span><br><span class="line">    A &#x3D; sigmoid(np.dot(w.T, X) + b)</span><br><span class="line">    for i in range(A.shape[1]):</span><br><span class="line">        if A[0, i] &gt; 0.5:    </span><br><span class="line">            Y_prediction[0, i] &#x3D; 1</span><br><span class="line">        else:</span><br><span class="line">            Y_prediction[0, i] &#x3D; 0</span><br><span class="line">    assert(Y_prediction.shape &#x3D;&#x3D; (1, m))</span><br><span class="line">    return Y_prediction</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> DeepLearning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OO-hw3</title>
      <link href="/2024/03/17/BUAA-OO-hw3/"/>
      <url>/2024/03/17/BUAA-OO-hw3/</url>
      
        <content type="html"><![CDATA[<h3 id="BUAA-OO-hw3"><a href="#BUAA-OO-hw3" class="headerlink" title="BUAA-OO-hw3"></a>BUAA-OO-hw3</h3><p>架构图如下:</p><p><img src="/2024/03/17/BUAA-OO-hw3/hw_3.png"></p><h4 id="任务清单"><a href="#任务清单" class="headerlink" title="任务清单"></a>任务清单</h4><ul><li>自定义函数嵌套</li><li>求导</li><li>简化</li></ul><h4 id="求导"><a href="#求导" class="headerlink" title="求导"></a>求导</h4><p>本次迭代增加了求导因子，需要对表达式进行求导运算。解决方案是添加DerivativeFactor，并在Poly中增加deprivePoly()方法，实现加减法连接的式子的求导。在Unit中增加deriveUnit()，实现乘法连接的式子的求导。</p><ul><li><p>DerivativeFactor:</p><p>数学表达式表示:<br>$$<br>dx(Expr)<br>$$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class DerivativeFactor implements Factor &#123;</span><br><span class="line">    private final Expr expr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>deprivePoly():</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public Poly derivePoly() &#123;</span><br><span class="line">        Poly derivative &#x3D; new Poly();</span><br><span class="line">        for (Unit it : units) &#123;</span><br><span class="line">            derivative.addUnitList(it.deriveUnit());</span><br><span class="line">        &#125;</span><br><span class="line">        return derivative;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>deriveUnit():</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList&lt;Unit&gt; deriveUnit() &#123;</span><br><span class="line">        if (exp.equals(BigInteger.ZERO)) &#123;</span><br><span class="line">            return expZero();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return expNotZero();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="自定义函数嵌套"><a href="#自定义函数嵌套" class="headerlink" title="自定义函数嵌套"></a>自定义函数嵌套</h4><p>解决方案是在FuncAnalysis类中的转换函数中进行递归调用，直至消除所有函数，得到最终的表达式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">while (real.contains(&quot;h&quot;) || real.contains(&quot;g&quot;) || real.contains(&quot;f&quot;)) &#123;</span><br><span class="line">            Lexer lexer &#x3D; new Lexer(real);</span><br><span class="line">            Parser parser &#x3D; new Parser(lexer);</span><br><span class="line">            Expr expr &#x3D; parser.parserExpr();</span><br><span class="line">            real &#x3D; expr.toPoly().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简化"><a href="#简化" class="headerlink" title="简化"></a>简化</h4><p>这一步大概是整个项目中最繁琐的，我将其分为三种情况:</p><ul><li><p>系数等于1:</p><p>只需要输出形如 $ x*exp() $ 的字符串。</p></li><li><p>系数等于-1:</p><p>只需要输出形如 $ -x*exp() $ 的字符串。</p></li><li><p>其他情况:</p><p>输出形如 $ coe * x * exp() $ 的字符串。</p></li></ul><p>在每一种情况下，需要对exp()内部的Poly进行提取最大公因数的操作，即在Poly中增加getGcd()方法，返回一个Hashmap，包含最大公因数和提取完成后的表达式。实现：$ \exp((2 * x-100 * x^2)) $  转变为  $ \exp((x-50 * x^2)^2 $。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public HashMap&lt;BigInteger, Poly&gt; getGcd() &#123;</span><br><span class="line">        Poly poly &#x3D; this.clone();</span><br><span class="line">        ArrayList&lt;BigInteger&gt; numbers &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        for (Unit it : poly.units) &#123;</span><br><span class="line">            if (!it.getCoe().equals(BigInteger.ZERO)) &#123;</span><br><span class="line">                numbers.add(it.getCoe()); &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        BigInteger gcd &#x3D; findGcd(numbers);</span><br><span class="line">        for (Unit it : poly.units) &#123;</span><br><span class="line">            BigInteger temp &#x3D; it.getCoe().divide(gcd);</span><br><span class="line">            it.setCoe(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        HashMap&lt;BigInteger, Poly&gt; hash &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        hash.put(gcd, poly);</span><br><span class="line">        return hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本次迭代难度不大，主要是简化部分太过繁琐，需要耗费一点时间。</p>]]></content>
      
      
      
        <tags>
            
            <tag> OO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OO-hw2</title>
      <link href="/2024/03/17/BUAA-OO-hw2/"/>
      <url>/2024/03/17/BUAA-OO-hw2/</url>
      
        <content type="html"><![CDATA[<h3 id="BUAA-OO-hw2"><a href="#BUAA-OO-hw2" class="headerlink" title="BUAA-OO-hw2"></a>BUAA-OO-hw2</h3><p>架构图如下:</p><p><img src="hw_2.png" alt=""></p><h4 id="任务清单"><a href="#任务清单" class="headerlink" title="任务清单"></a>任务清单</h4><p>增加了exp()因子，新增自定义函数因子。</p><h4 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h4><p>本次作业并不适用于第一次作业的架构，故选择重构。此次重构增加Unit类和Poly类，以替代Hashmap来进行表达式的计算和简化。</p><h5 id="Unit类"><a href="#Unit类" class="headerlink" title="Unit类:"></a>Unit类:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Unit &#123;</span><br><span class="line">    private BigInteger coe;</span><br><span class="line">    private final BigInteger exp;</span><br><span class="line">    private final Poly expRatio;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数学公式表示:</p><script type="math/tex; mode=display">a*x^b*exp((\sum_{i=1}^na_i*x_i^b*exp))</script><p>coe为系数，exp为varible的指数，expRatio为exp()因子的表达式因子的Poly形式。</p><h5 id="Poly类"><a href="#Poly类" class="headerlink" title="Poly类:"></a>Poly类:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Poly &#123;</span><br><span class="line">    private ArrayList&lt;Unit&gt; units;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数学公式表示:</p><script type="math/tex; mode=display">\sum_{i=1}^nUnit_i</script><p>用ArrayList存储各个unit，最后用toString()方法输出最终表达式。</p><h4 id="自定义函数处理"><a href="#自定义函数处理" class="headerlink" title="自定义函数处理"></a>自定义函数处理</h4><p>专门新建一个FunctAnalysis类用于对函数表达式的处理和转换。处理主要是提取出函数名和表达式，转换是将待处理的带函数的表达式转换为无函数表达式。</p><h5 id="FunctAnalysis"><a href="#FunctAnalysis" class="headerlink" title="FunctAnalysis"></a>FunctAnalysis</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class FuncAnalysis &#123;</span><br><span class="line">    private static HashMap&lt;String, String&gt; funcMap &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    private static HashMap&lt;String, ArrayList&lt;String&gt;&gt; parametric &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>funcMap: 用于对函数名和函数表达式的映射。</li><li>parametric: 用于函数名对于函数的未知变量的映射。</li></ul><h5 id="FuncFactor"><a href="#FuncFactor" class="headerlink" title="FuncFactor"></a>FuncFactor</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class FuncFactor implements Factor &#123;</span><br><span class="line">    private final String result;</span><br><span class="line">    private final Expr expr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>result: 经过FunctAnalysis转换后的表达式字符串。</li><li>expr: 将result转换为Expr类的形式。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本次作业对上次作业进行重构，构建了可拓展性更好的架构。缺点在于没有对表达式进行化简，在后续迭代中需要进一步补充。</p>]]></content>
      
      
      
        <tags>
            
            <tag> OO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-Lab1</title>
      <link href="/2024/03/15/BUAA-OS-Lab1/"/>
      <url>/2024/03/15/BUAA-OS-Lab1/</url>
      
        <content type="html"><![CDATA[<h3 id="BUAA-OS-Lab1"><a href="#BUAA-OS-Lab1" class="headerlink" title="BUAA_OS_Lab1"></a>BUAA_OS_Lab1</h3><h4 id="一、实验思考题"><a href="#一、实验思考题" class="headerlink" title="一、实验思考题"></a>一、实验思考题</h4><h5 id="Thinking-1-1"><a href="#Thinking-1-1" class="headerlink" title="Thinking 1.1"></a>Thinking 1.1</h5><blockquote><p>请阅读 附录中的编译链接详解，尝试分别使用实验环境中的原生x86 工具 链（gcc、ld、readelf、objdump 等）和 MIPS 交叉编译工具链（带有 mips-linux-gnu-前缀），重复其中的编译和解析过程，观察相应的结果，并解释其中向objdump传入的参数的含义。</p></blockquote><p>执行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E hello.c</span><br></pre></td></tr></table></figure><p>得到结果：C语言的预处理器将头文件的内容添加到了源文件中</p><p><img src="gcc_E.png" alt=""></p><p>执行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello.c</span><br></pre></td></tr></table></figure><p>得到hello.o文件，在对hello.o文件进行反汇编，导入到obj文件中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -DS hello.o &gt; obj</span><br></pre></td></tr></table></figure><p>obj中main函数部分代码如下所示:</p><p><img src="obj_main.png" alt=""></p><p>执行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -o hello hello.c</span><br><span class="line">objdump -DS hello &gt; obj_hello</span><br></pre></td></tr></table></figure><p>obj_hello部分结果如图:</p><p><img src="obj_hello.png" alt=""></p><p>objdump传入的第一个参数为需要反编译的文件名, 第二个参数为反编译结果输入到的文件。</p><h5 id="Thinking-1-2"><a href="#Thinking-1-2" class="headerlink" title="Thinking 1.2"></a>Thinking 1.2</h5><blockquote><p>尝试使用我们编写的readelf程序，解析之前在target目录下生成的内核ELF文件。</p><p>也许你会发现我们编写的readelf程序是不能解析readelf文件本身的，而我们刚 才介绍的系统工具readelf则可以解析，这是为什么呢？（提示：尝试使用readelf-h，并阅读tools/readelf目录下的Makefile，观察readelf与hello的不同）</p></blockquote><p>解析结果:</p><p><img src="readelf_hello.png" alt=""></p><p>执行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -h hello</span><br></pre></td></tr></table></figure><p>结果如图:</p><p><img src="readelf_hello1.png" alt=""></p><p>执行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -h .&#x2F;readelf</span><br></pre></td></tr></table></figure><p>结果如图:</p><p><img src="readelf_readelf.png" alt=""></p><p>由上可知：hello的文件类型是EXEC(可执行文件)，而readelf的文件类型是DYN(地址独立的可执行文件)，readelf程序本身只能解析可执行文件，所以解析不了readelf文件本身，而系统工具readelf可以解析所有可执行文件，所以可以解析./readelf。</p><h5 id="Thinking-1-3"><a href="#Thinking-1-3" class="headerlink" title="Thinking 1.3"></a>Thinking 1.3</h5><blockquote><p>在理论课上我们了解到，MIPS体系结构上电时，启动入口地址为0xBFC00000 （其实启动入口地址是根据具体型号而定的，由硬件逻辑确定，也有可能不是这个地址，但 一定是一个确定的地址），但实验操作系统的内核入口并没有放在上电启动地址，而是按照内存布局图放置。思考为什么这样放置内核还能保证内核入口被正确跳转到？ （提示：思考实验中启动过程的两阶段分别由谁执行。）</p></blockquote><p>因为引导加载程序在初始化虚拟内存系统时，会将内核映像加载到虚拟地址空间的某个位置，并设置相应的页表条目。这样，CPU就可以通过虚拟地址访问内核，之后会执行一个跳转指令，将控制权交给内核的入口点。</p><h4 id="二、实验难点"><a href="#二、实验难点" class="headerlink" title="二、实验难点"></a>二、实验难点</h4><h5 id="readelf-c文件编写"><a href="#readelf-c文件编写" class="headerlink" title="readelf.c文件编写"></a>readelf.c文件编写</h5><p>需要通过教程中的结构体数据类型和变量定义，查表得到节头表的地址、节头数量和大小。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sh_table &#x3D; (const void *)((char *)binary + ehdr-&gt;e_shoff);</span><br><span class="line">sh_entry_count &#x3D; ehdr-&gt;e_shnum;</span><br><span class="line">sh_entry_size &#x3D; ehdr-&gt;e_shentsize;</span><br></pre></td></tr></table></figure><p>要获得每个节头的地址需要用节头表指针加上index与节头大小的乘积。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shdr &#x3D; (Elf32_Shdr *)((char *)sh_table + (i * sh_entry_size));</span><br></pre></td></tr></table></figure><h5 id="补全kernel-lds文件"><a href="#补全kernel-lds文件" class="headerlink" title="补全kernel.lds文件"></a>补全kernel.lds文件</h5><p>根据教程格式写即可，注意内核的位置。</p><h5 id="init-start-S文件补全"><a href="#init-start-S文件补全" class="headerlink" title="init/start.S文件补全"></a>init/start.S文件补全</h5><p>将栈指针指向kernelbase，跳转到mips_init函数即可。</p><h5 id="完成vprintfmt-函数"><a href="#完成vprintfmt-函数" class="headerlink" title="完成vprintfmt()函数"></a>完成vprintfmt()函数</h5><p>由于vprintfmt()函数的实现方法有很多种，所以在完成这一部分时可以不按照教程代码注释的指引来写。需要注意的是循环的break条件，遇见’\0’需要跳出循环，不然会陷入死循环。还需要注意实现解析各个符号的含义，按照教程来即可。</p><h4 id="三、实验体会"><a href="#三、实验体会" class="headerlink" title="三、实验体会"></a>三、实验体会</h4><p>本次实验总体而言难度不大，但由于教程写的比较难懂，所以需要多耗费一些时间在教程的阅读和理解上面。同时也需要注意一些细节，容易在细节上出错。</p>]]></content>
      
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA_OO_hw1</title>
      <link href="/2024/03/11/BUAA-OO-hw1/"/>
      <url>/2024/03/11/BUAA-OO-hw1/</url>
      
        <content type="html"><![CDATA[<h3 id="BUAA-OO-hw1"><a href="#BUAA-OO-hw1" class="headerlink" title="BUAA_OO_hw1"></a>BUAA_OO_hw1</h3><p>架构图如下：</p><p><img src="hw_1.png" alt=""></p><h4 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h4><p>创建Processor类对输入的表达式进行预处理，去除空格、合并符号、将乘方拆分为多个x相乘的形式(例如：<em>x^3</em>  → x <em> x </em> x)</p><h4 id="expr包设计"><a href="#expr包设计" class="headerlink" title="expr包设计"></a>expr包设计</h4><p><img src="expr.png" alt=""></p><h5 id="Factor"><a href="#Factor" class="headerlink" title="Factor"></a>Factor</h5><p>本次作业因子分为两种: Number和Varible。为了方便后续的表达式运算，我根据因子计算的性质在其中设计了一个Hashmap来存储其指数和系数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Number &#123;</span><br><span class="line">    </span><br><span class="line">    private HashMap&lt;Integer, BigInteger&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    public HashMap&lt;Integer, BigInteger&gt; getMap() &#123;</span><br><span class="line">        return map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Var &#123;</span><br><span class="line"></span><br><span class="line">    private final HashMap&lt;Integer, BigInteger&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public HashMap&lt;Integer, BigInteger&gt; getMap() &#123;</span><br><span class="line">        return map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Term"><a href="#Term" class="headerlink" title="Term"></a>Term</h5><p>Term由Factor相乘得到，因此也使用Hashmap存储其指数和系数，同时为了乘法计算，使用mergeFactor()方法对Factor的乘法运算进行处理。</p><p>形式:</p><script type="math/tex; mode=display">a*x^b</script><h5 id="Expr"><a href="#Expr" class="headerlink" title="Expr"></a>Expr</h5><p>Expr由Term相加得到，也使用Hashmap存储每个Term的指数和系数，增加mergeTerm()方法对Term的加法进行处理。</p><p>形式:</p><script type="math/tex; mode=display">\sum_{i=1}^na_i*x_i^b</script><h4 id="递归下降"><a href="#递归下降" class="headerlink" title="递归下降"></a>递归下降</h4><p>按照训练给出的架构来做就好了：</p><h5 id="Lexer"><a href="#Lexer" class="headerlink" title="Lexer"></a>Lexer</h5><p>将processor处理后的表达式输入到Lexer中，Lexer通过next()方法解析表达式，再通过peek()方法将解析出的”词”传入Parser中。</p><h5 id="Parser"><a href="#Parser" class="headerlink" title="Parser"></a>Parser</h5><p>对Lexer传出的curToken在进行分析，运用parseExpr()方法获得Expr、parseTerm()获得Term、parseFactor()获得Factor。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>由于本次作业表达式形式相对简单，所以我也采用了Hashmap这种简单的方法进行处理。好处就是加减乘除计算处理非常简单，不需要递归。坏处就是可拓展性极差，只适用于第一次作业这种特定形式的表达式，因此在后续迭代中需要进行重构。</p>]]></content>
      
      
      
        <tags>
            
            <tag> OO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA_OS_Lab0</title>
      <link href="/2024/03/11/BUAA-OS-Lab0/"/>
      <url>/2024/03/11/BUAA-OS-Lab0/</url>
      
        <content type="html"><![CDATA[<h3 id="BUAA-OS-Lab0"><a href="#BUAA-OS-Lab0" class="headerlink" title="BUAA_OS_Lab0"></a>BUAA_OS_Lab0</h3><h4 id="一、实验思考题"><a href="#一、实验思考题" class="headerlink" title="一、实验思考题"></a>一、实验思考题</h4><h5 id="Thinking-0-1"><a href="#Thinking-0-1" class="headerlink" title="Thinking 0.1"></a>Thinking 0.1</h5><ul><li><p>执行cat Untracked.txt后的结果：README.txt文件位于untracked区</p><p><img src="/2024/03/11/BUAA-OS-Lab0/cat_Untracked.png" alt="cat_untracked"></p></li><li><p>执行cat Stage.txt后的结果：README.txt文件位于staged区</p><p><img src="/2024/03/11/BUAA-OS-Lab0/cat_stage.png"></p></li><li><p>修改修改README.txt 文件，再执行命令git status &gt; Modified.txt。执行命令cat Modified.txt后的结果：</p><p><img src="/2024/03/11/BUAA-OS-Lab0/modified.png"></p></li></ul><p>结果和第一次执行 add 命令之前的 status 不一样。第一次执行 add 命令之前的README.txt的 status是未跟踪，修改后的status是未暂存以备提交的变更</p><p>原因是执行add命令前README.txt未被跟踪，后续执行add命令文件被跟踪修改后未提交，所以处于未暂存状态。</p><h5 id="Thinking-0-2"><a href="#Thinking-0-2" class="headerlink" title="Thinking 0.2"></a>Thinking 0.2</h5><blockquote><p>Thinking0.2 仔细看看0.10，思考一下箭头中的add thefile、stage thefile和 commit分别对应的是Git里的哪些命令呢？</p></blockquote><p><img src="/2024/03/11/BUAA-OS-Lab0/status.png"></p><p>add the file 对应指令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add</span><br></pre></td></tr></table></figure><p>stage the file 对应指令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add</span><br></pre></td></tr></table></figure><p>commit 对应指令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit</span><br></pre></td></tr></table></figure><h5 id="Thinking-0-3"><a href="#Thinking-0-3" class="headerlink" title="Thinking 0.3"></a>Thinking 0.3</h5><p><img src="/2024/03/11/BUAA-OS-Lab0/git_structure.png"></p><blockquote><p>1、代码文件print.c 被错误删除时，应当使用什么命令将其恢复？</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- print.c</span><br></pre></td></tr></table></figure><blockquote><p>2、代码文件 print.c 被错误删除后，执行了 git rm print.c 命令，此时应当 使用什么命令将其恢复？</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout HEAD print.c</span><br></pre></td></tr></table></figure><blockquote><p>3、无关文件 hello.txt 已经被添加到暂存区时，如何在不删除此文件的前提下将其移出暂存区？</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD hello.txt</span><br></pre></td></tr></table></figure><h5 id="Thinking-0-4"><a href="#Thinking-0-4" class="headerlink" title="Thinking 0.4"></a>Thinking 0.4</h5><ul><li><p>在文件里加入Testing 1，git add，git commit，提交说明记为1。模仿上述做法，把1分别改为2和3，再提交两次。<img src="/2024/03/11/BUAA-OS-Lab0/4_add.png"></p></li><li><p>使用git log命令查看提交日志，看是否已经有三次提交，记下提交说明为3的哈希值。</p><p><img src="/2024/03/11/BUAA-OS-Lab0/log_1.png"></p></li><li><p>进行版本回退。执行命令git reset –hard HEAD^后，再执行git log，观 察其变化。</p><p><img src="/2024/03/11/BUAA-OS-Lab0/log_2.png"></p></li><li><p>找到提交说明为1的哈希值，执行命令git reset –hard后，再执 行git log，观察其变化。</p><p><img src="/2024/03/11/BUAA-OS-Lab0/log_3.png"></p></li><li><p>现在已经回到了旧版本，为了再次回到新版本，执行git reset –hard ，再执行git log，观察其变化。</p><p><img src="/2024/03/11/BUAA-OS-Lab0/log_4.png"></p></li></ul><h5 id="Thinking-0-5"><a href="#Thinking-0-5" class="headerlink" title="Thinking 0.5"></a>Thinking 0.5</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo first</span><br></pre></td></tr></table></figure><p><img src="/2024/03/11/BUAA-OS-Lab0/echo_1.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo second &gt; output.txt</span><br></pre></td></tr></table></figure><p><img src="/2024/03/11/BUAA-OS-Lab0/echo_2.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo third &gt; output.txt</span><br></pre></td></tr></table></figure><p><img src="/2024/03/11/BUAA-OS-Lab0/echo_3.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo forth &gt;&gt; output.txt</span><br></pre></td></tr></table></figure><p><img src="/2024/03/11/BUAA-OS-Lab0/echo_4.png"></p><h5 id="Thinking-0-6"><a href="#Thinking-0-6" class="headerlink" title="Thinking 0.6"></a>Thinking 0.6</h5><p>command文件内容：</p><p><img src="/2024/03/11/BUAA-OS-Lab0/command.png"></p><p>result文件内容：</p><p><img src="/2024/03/11/BUAA-OS-Lab0/result.png"></p><p>test文件命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo ...</span><br></pre></td></tr></table></figure><p>将…中的内容输出到result中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a&#x3D;1</span><br><span class="line">b&#x3D;2</span><br><span class="line">c&#x3D;$[$a+$b]</span><br></pre></td></tr></table></figure><p>将a赋值为1，b赋值为2，c赋值为3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo $c&gt;file1</span><br><span class="line">echo $b&gt;file2</span><br><span class="line">echo $a&gt;file3</span><br></pre></td></tr></table></figure><p>将a输出到为file3，c输出到为file1，b输出到为file2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat file1&gt;file4</span><br><span class="line">cat file2&gt;&gt;file4</span><br><span class="line">cat file3&gt;&gt;file4</span><br><span class="line">cat file4&gt;&gt;result</span><br></pre></td></tr></table></figure><p>将file1 file2 file3的值依次输出到file4中，再将file4的值输出到result尾部。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo echo Shell Start</span><br><span class="line">echo &#39;echo Shell Start&#39;</span><br></pre></td></tr></table></figure><p>效果无区别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo echo $c&gt;file1</span><br><span class="line">echo ’echo $c&gt;file1‘</span><br></pre></td></tr></table></figure><p>效果有区别，上面的输出结果为echo，下面输出结果为echo $c&gt;file1</p><h4 id="二、实验难点分析"><a href="#二、实验难点分析" class="headerlink" title="二、实验难点分析"></a>二、实验难点分析</h4><h5 id="bash脚本编写"><a href="#bash脚本编写" class="headerlink" title="bash脚本编写"></a>bash脚本编写</h5><p>[sed指令的使用]</p><blockquote><p>在src&#x2F;sh_test 目录下，有一个file 文件和hello_os.sh 文件。hello_os.sh 是 一个未完成的脚本文档，请同学们借助shell编程的知识，将其补完，以实现通过命令bash hello_os.sh AAA BBB，在 hello_os.sh 所处的目录新建一个名为 BBB 的文件，其内容为AAA文件的第8、32、128、512、1024行的内容提取(AAA文件行数一定超过1024行)。[注 意：对于命令bashhello_os.sh AAABBB，AAA及BBB可为任何合法文件的名称，例如 bashhello_os.sh filehello_os.c，若已有hello_os.c文件，则将其原有内容覆盖]</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">sed -n &#39;8p, 32p, 128p, 512p, 1024p&#39; $1 &gt; $2</span><br></pre></td></tr></table></figure><p>使用sed指令将参数$1文件中指定行输出到$2中</p><blockquote><p>在Lab0工作区的csc&#x2F;code目录下，存在fibo.c、main.c，其中fibo.c有点小 问题，还有一个未补全的modify.sh文件，将其补完，以实现通过命令bash modify.sh fibo.c char int，可以将fibo.c中所有的char字符串更改为int字符串。[注意：对于 命令bashmodify.sh fibo.ccharint，fibo.c可为任何合法文件名，char及int可 以是任何字符串，评测时评测modify.sh的正确性，而不是检查修改后fibo.c的正确性]</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">sed -i &quot;s&#x2F;$2&#x2F;$3&#x2F;g&quot; $1</span><br></pre></td></tr></table></figure><p>[循环语句的使用]</p><blockquote><p>在Lab0工作区ray&#x2F;sh_test1目录中，含有100个子目录file1<del>file100，还存 在一个名为changefile.sh的文件，将其补完，以实现通过命令bashchangefile.sh，可 以删除该目录内file71</del>file100共计30个子目录，将file41<del>file70共计30个子目录 重命名为newfile41</del>newfile70。[注意：评测时仅检测changefile.sh的正确性]</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">a&#x3D;1</span><br><span class="line">while [ $a -le 100 ]</span><br><span class="line">do</span><br><span class="line">if [ $a -gt 70 ]</span><br><span class="line">then</span><br><span class="line">rm -r file$a</span><br><span class="line">elif [ $a -gt 40 ]</span><br><span class="line">then</span><br><span class="line">mv file$a newfile$a</span><br><span class="line">fi</span><br><span class="line">a&#x3D;$((a+1))</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>[grep和awk指令的使用 重定向和管道的运用]</p><blockquote><p>在Lab0工作区的ray&#x2F;sh_test2目录下，存在一个未补全的search.sh文件， 将其补完，以实现通过命令bash search.sh file int result，可以在当前目录下生成 result文件，内容为file文件含有int字符串所在的行数，即若有多行含有int字符串 需要全部输出。[注意：对于命令bashsearch.sh file int result，file及result可 为任何合法文件名称，int可为任何合法字符串，若已有result文件，则将其原有内容覆 盖，匹配时大小写不忽略]</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">grep -n $2 $1 | awk -F : &#39;&#123;prin $1&#125;&#39; &gt; $3</span><br></pre></td></tr></table></figure><h5 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h5><blockquote><p>补全后的palindrome.c、Makefile、hello_os.sh依次复制到路径dst&#x2F;palindrome.c, dst&#x2F;Makefile,dst&#x2F;sh_test&#x2F;hello_os.sh[注意：文件名和路径必须与题目要求相同]</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mv palindrome.c ..&#x2F;dst</span><br><span class="line">mv Makefile ..&#x2F;dst</span><br><span class="line">mv hello_os.sh ..&#x2F;dst&#x2F;sh_test</span><br></pre></td></tr></table></figure><h5 id="Makefile编写"><a href="#Makefile编写" class="headerlink" title="Makefile编写"></a>Makefile编写</h5><blockquote><p>Lab0工作区的csc&#x2F;code&#x2F;fibo.c成功更换字段后(bashmodify.shfibo.cchar int)，现已有csc&#x2F;Makefile和csc&#x2F;code&#x2F;Makefile，补全两个Makefile文件，要求在 csc目录下通过命令make可在csc&#x2F;code目录中生成fibo.o、main.o，在csc目录中生 成可执行文件fibo，再输入命令makeclean后只删除两个.o文件。[注意：不能修改 fibo.h和main.c文件中的内容，提交的文件中fibo.c必须是修改后正确的fibo.c，可 执行文件fibo作用是输入一个整数n(从stdin输入n)，可以输出斐波那契数列前n项， 每一项之间用空格分开。比如n&#x3D;5，输出11235]</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">all: fibo                                                            </span><br><span class="line">fibo: code&#x2F;fibo.o code&#x2F;main.o</span><br><span class="line">gcc -o fibo code&#x2F;fibo.o code&#x2F;main.o</span><br><span class="line">code&#x2F;fibo.o: code&#x2F;fibo.c</span><br><span class="line">gcc -c code&#x2F;fibo.c -o code&#x2F;fibo.o -I include</span><br><span class="line">code&#x2F;main.o: code&#x2F;main.c</span><br><span class="line">gcc -c code&#x2F;main.c -o code&#x2F;main.o -I include</span><br><span class="line">clean:</span><br><span class="line">rm -r code&#x2F;main.o code&#x2F;fibo.o</span><br></pre></td></tr></table></figure><h4 id="三、实验体会"><a href="#三、实验体会" class="headerlink" title="三、实验体会"></a>三、实验体会</h4><p>由于上机前没有仔细看教程，导致对Linux一些指令用法的不熟悉、对Makefile和bash脚本写法不熟悉。这也导致了我在上机时写的很慢。在仔细阅读教程后，终于对自己犯的一些错误恍然大悟，对git、Linux命令、bash脚本编写和Makefile编写有了进一步的认识。总体而言，本次实验难度不大，主要是考察我们对基础知识的理解。</p>]]></content>
      
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello world</title>
      <link href="/2024/03/11/Hello-world/"/>
      <url>/2024/03/11/Hello-world/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
