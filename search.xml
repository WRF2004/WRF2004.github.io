<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>DeepLearning</title>
      <link href="/2024/03/17/DeepLearning/"/>
      <url>/2024/03/17/DeepLearning/</url>
      
        <content type="html"><![CDATA[<h3 id="DeepLearning"><a href="#DeepLearning" class="headerlink" title="DeepLearning"></a>DeepLearning</h3><h4 id="Logistic-Regression"><a href="#Logistic-Regression" class="headerlink" title="Logistic Regression"></a>Logistic Regression</h4><h5 id="Basic-function"><a href="#Basic-function" class="headerlink" title="Basic function:"></a>Basic function:</h5><p>$$<br>w,x \in R^{n_x},x&#x3D; \begin{pmatrix} x_1\ x_2\ x_3\ …\x_{n_x}\end{pmatrix}, b \in R\ \hat y&#x3D;\sigma(w^Tx+b),\hat y \in (0,1)\\sigma(z)&#x3D;\frac{1}{1+e^{-z}} \<br>$$</p><h5 id="Loss-function"><a href="#Loss-function" class="headerlink" title="Loss function:"></a>Loss function:</h5><p>$$<br>L(\hat y, y)&#x3D;-[ y\log \hat y +( 1-y ) \log (1-\hat y)]<br>$$</p><h5 id="Cost-function"><a href="#Cost-function" class="headerlink" title="Cost function"></a>Cost function</h5><p>$$<br>J(w,b)&#x3D;\frac{1}{m}\sum _{i&#x3D;1}^{m}L(\hat y^{(i)}, y^{(i)})<br>$$</p>]]></content>
      
      
      
        <tags>
            
            <tag> DeepLearning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OO-hw3</title>
      <link href="/2024/03/17/BUAA-OO-hw3/"/>
      <url>/2024/03/17/BUAA-OO-hw3/</url>
      
        <content type="html"><![CDATA[<h3 id="BUAA-OO-hw3"><a href="#BUAA-OO-hw3" class="headerlink" title="BUAA-OO-hw3"></a>BUAA-OO-hw3</h3><p>架构图如下:</p><p><img src="/2024/03/17/BUAA-OO-hw3/hw_3.png"></p><h4 id="任务清单"><a href="#任务清单" class="headerlink" title="任务清单"></a>任务清单</h4><ul><li>自定义函数嵌套</li><li>求导</li><li>简化</li></ul><h4 id="求导"><a href="#求导" class="headerlink" title="求导"></a>求导</h4><p>本次迭代增加了求导因子，需要对表达式进行求导运算。解决方案是添加DerivativeFactor，并在Poly中增加deprivePoly()方法，实现加减法连接的式子的求导。在Unit中增加deriveUnit()，实现乘法连接的式子的求导。</p><ul><li><p>DerivativeFactor:</p><p>数学表达式表示:<br>$$<br>dx(Expr)<br>$$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class DerivativeFactor implements Factor &#123;</span><br><span class="line">    private final Expr expr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>deprivePoly():</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public Poly derivePoly() &#123;</span><br><span class="line">        Poly derivative &#x3D; new Poly();</span><br><span class="line">        for (Unit it : units) &#123;</span><br><span class="line">            derivative.addUnitList(it.deriveUnit());</span><br><span class="line">        &#125;</span><br><span class="line">        return derivative;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>deriveUnit():</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList&lt;Unit&gt; deriveUnit() &#123;</span><br><span class="line">        if (exp.equals(BigInteger.ZERO)) &#123;</span><br><span class="line">            return expZero();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return expNotZero();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="自定义函数嵌套"><a href="#自定义函数嵌套" class="headerlink" title="自定义函数嵌套"></a>自定义函数嵌套</h4><p>解决方案是在FuncAnalysis类中的转换函数中进行递归调用，直至消除所有函数，得到最终的表达式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">while (real.contains(&quot;h&quot;) || real.contains(&quot;g&quot;) || real.contains(&quot;f&quot;)) &#123;</span><br><span class="line">            Lexer lexer &#x3D; new Lexer(real);</span><br><span class="line">            Parser parser &#x3D; new Parser(lexer);</span><br><span class="line">            Expr expr &#x3D; parser.parserExpr();</span><br><span class="line">            real &#x3D; expr.toPoly().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简化"><a href="#简化" class="headerlink" title="简化"></a>简化</h4><p>这一步大概是整个项目中最繁琐的，我将其分为三种情况:</p><ul><li><p>系数等于1:</p><p>只需要输出形如 $ x*exp() $ 的字符串。</p></li><li><p>系数等于-1:</p><p>只需要输出形如 $ -x*exp() $ 的字符串。</p></li><li><p>其他情况:</p><p>输出形如 $ coe * x * exp() $ 的字符串。</p></li></ul><p>在每一种情况下，需要对exp()内部的Poly进行提取最大公因数的操作，即在Poly中增加getGcd()方法，返回一个Hashmap，包含最大公因数和提取完成后的表达式。实现：$ \exp((2 * x-100 * x^2)) $  转变为  $ \exp((x-50 * x^2)^2 $。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public HashMap&lt;BigInteger, Poly&gt; getGcd() &#123;</span><br><span class="line">        Poly poly &#x3D; this.clone();</span><br><span class="line">        ArrayList&lt;BigInteger&gt; numbers &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        for (Unit it : poly.units) &#123;</span><br><span class="line">            if (!it.getCoe().equals(BigInteger.ZERO)) &#123;</span><br><span class="line">                numbers.add(it.getCoe()); &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        BigInteger gcd &#x3D; findGcd(numbers);</span><br><span class="line">        for (Unit it : poly.units) &#123;</span><br><span class="line">            BigInteger temp &#x3D; it.getCoe().divide(gcd);</span><br><span class="line">            it.setCoe(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        HashMap&lt;BigInteger, Poly&gt; hash &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        hash.put(gcd, poly);</span><br><span class="line">        return hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本次迭代难度不大，主要是简化部分太过繁琐，需要耗费一点时间。</p>]]></content>
      
      
      
        <tags>
            
            <tag> OO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OO-hw2</title>
      <link href="/2024/03/17/BUAA-OO-hw2/"/>
      <url>/2024/03/17/BUAA-OO-hw2/</url>
      
        <content type="html"><![CDATA[<h3 id="BUAA-OO-hw2"><a href="#BUAA-OO-hw2" class="headerlink" title="BUAA-OO-hw2"></a>BUAA-OO-hw2</h3><p>架构图如下:</p><p><img src="hw_2.png" alt=""></p><h4 id="任务清单"><a href="#任务清单" class="headerlink" title="任务清单"></a>任务清单</h4><p>增加了exp()因子，新增自定义函数因子。</p><h4 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h4><p>本次作业并不适用于第一次作业的架构，故选择重构。此次重构增加Unit类和Poly类，以替代Hashmap来进行表达式的计算和简化。</p><h5 id="Unit类"><a href="#Unit类" class="headerlink" title="Unit类:"></a>Unit类:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Unit &#123;</span><br><span class="line">    private BigInteger coe;</span><br><span class="line">    private final BigInteger exp;</span><br><span class="line">    private final Poly expRatio;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数学公式表示:</p><script type="math/tex; mode=display">a*x^b*exp((\sum_{i=1}^na_i*x_i^b*exp))</script><p>coe为系数，exp为varible的指数，expRatio为exp()因子的表达式因子的Poly形式。</p><h5 id="Poly类"><a href="#Poly类" class="headerlink" title="Poly类:"></a>Poly类:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Poly &#123;</span><br><span class="line">    private ArrayList&lt;Unit&gt; units;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数学公式表示:</p><script type="math/tex; mode=display">\sum_{i=1}^nUnit_i</script><p>用ArrayList存储各个unit，最后用toString()方法输出最终表达式。</p><h4 id="自定义函数处理"><a href="#自定义函数处理" class="headerlink" title="自定义函数处理"></a>自定义函数处理</h4><p>专门新建一个FunctAnalysis类用于对函数表达式的处理和转换。处理主要是提取出函数名和表达式，转换是将待处理的带函数的表达式转换为无函数表达式。</p><h5 id="FunctAnalysis"><a href="#FunctAnalysis" class="headerlink" title="FunctAnalysis"></a>FunctAnalysis</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class FuncAnalysis &#123;</span><br><span class="line">    private static HashMap&lt;String, String&gt; funcMap &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    private static HashMap&lt;String, ArrayList&lt;String&gt;&gt; parametric &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>funcMap: 用于对函数名和函数表达式的映射。</li><li>parametric: 用于函数名对于函数的未知变量的映射。</li></ul><h5 id="FuncFactor"><a href="#FuncFactor" class="headerlink" title="FuncFactor"></a>FuncFactor</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class FuncFactor implements Factor &#123;</span><br><span class="line">    private final String result;</span><br><span class="line">    private final Expr expr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>result: 经过FunctAnalysis转换后的表达式字符串。</li><li>expr: 将result转换为Expr类的形式。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本次作业对上次作业进行重构，构建了可拓展性更好的架构。缺点在于没有对表达式进行化简，在后续迭代中需要进一步补充。</p>]]></content>
      
      
      
        <tags>
            
            <tag> OO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-Lab1</title>
      <link href="/2024/03/15/BUAA-OS-Lab1/"/>
      <url>/2024/03/15/BUAA-OS-Lab1/</url>
      
        <content type="html"><![CDATA[<h3 id="BUAA-OS-Lab1"><a href="#BUAA-OS-Lab1" class="headerlink" title="BUAA_OS_Lab1"></a>BUAA_OS_Lab1</h3><h4 id="一、实验思考题"><a href="#一、实验思考题" class="headerlink" title="一、实验思考题"></a>一、实验思考题</h4><h5 id="Thinking-1-1"><a href="#Thinking-1-1" class="headerlink" title="Thinking 1.1"></a>Thinking 1.1</h5><blockquote><p>请阅读 附录中的编译链接详解，尝试分别使用实验环境中的原生x86 工具 链（gcc、ld、readelf、objdump 等）和 MIPS 交叉编译工具链（带有 mips-linux-gnu-前缀），重复其中的编译和解析过程，观察相应的结果，并解释其中向objdump传入的参数的含义。</p></blockquote><p>执行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E hello.c</span><br></pre></td></tr></table></figure><p>得到结果：C语言的预处理器将头文件的内容添加到了源文件中</p><p><img src="gcc_E.png" alt=""></p><p>执行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello.c</span><br></pre></td></tr></table></figure><p>得到hello.o文件，在对hello.o文件进行反汇编，导入到obj文件中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -DS hello.o &gt; obj</span><br></pre></td></tr></table></figure><p>obj中main函数部分代码如下所示:</p><p><img src="obj_main.png" alt=""></p><p>执行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -o hello hello.c</span><br><span class="line">objdump -DS hello &gt; obj_hello</span><br></pre></td></tr></table></figure><p>obj_hello部分结果如图:</p><p><img src="obj_hello.png" alt=""></p><p>objdump传入的第一个参数为需要反编译的文件名, 第二个参数为反编译结果输入到的文件。</p><h5 id="Thinking-1-2"><a href="#Thinking-1-2" class="headerlink" title="Thinking 1.2"></a>Thinking 1.2</h5><blockquote><p>尝试使用我们编写的readelf程序，解析之前在target目录下生成的内核ELF文件。</p><p>也许你会发现我们编写的readelf程序是不能解析readelf文件本身的，而我们刚 才介绍的系统工具readelf则可以解析，这是为什么呢？（提示：尝试使用readelf-h，并阅读tools/readelf目录下的Makefile，观察readelf与hello的不同）</p></blockquote><p>解析结果:</p><p><img src="readelf_hello.png" alt=""></p><p>执行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -h hello</span><br></pre></td></tr></table></figure><p>结果如图:</p><p><img src="readelf_hello1.png" alt=""></p><p>执行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -h .&#x2F;readelf</span><br></pre></td></tr></table></figure><p>结果如图:</p><p><img src="readelf_readelf.png" alt=""></p><p>由上可知：hello的文件类型是EXEC(可执行文件)，而readelf的文件类型是DYN(地址独立的可执行文件)，readelf程序本身只能解析可执行文件，所以解析不了readelf文件本身，而系统工具readelf可以解析所有可执行文件，所以可以解析./readelf。</p><h5 id="Thinking-1-3"><a href="#Thinking-1-3" class="headerlink" title="Thinking 1.3"></a>Thinking 1.3</h5><blockquote><p>在理论课上我们了解到，MIPS体系结构上电时，启动入口地址为0xBFC00000 （其实启动入口地址是根据具体型号而定的，由硬件逻辑确定，也有可能不是这个地址，但 一定是一个确定的地址），但实验操作系统的内核入口并没有放在上电启动地址，而是按照内存布局图放置。思考为什么这样放置内核还能保证内核入口被正确跳转到？ （提示：思考实验中启动过程的两阶段分别由谁执行。）</p></blockquote><p>因为引导加载程序在初始化虚拟内存系统时，会将内核映像加载到虚拟地址空间的某个位置，并设置相应的页表条目。这样，CPU就可以通过虚拟地址访问内核，之后会执行一个跳转指令，将控制权交给内核的入口点。</p><h4 id="二、实验难点"><a href="#二、实验难点" class="headerlink" title="二、实验难点"></a>二、实验难点</h4><h5 id="readelf-c文件编写"><a href="#readelf-c文件编写" class="headerlink" title="readelf.c文件编写"></a>readelf.c文件编写</h5><p>需要通过教程中的结构体数据类型和变量定义，查表得到节头表的地址、节头数量和大小。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sh_table &#x3D; (const void *)((char *)binary + ehdr-&gt;e_shoff);</span><br><span class="line">sh_entry_count &#x3D; ehdr-&gt;e_shnum;</span><br><span class="line">sh_entry_size &#x3D; ehdr-&gt;e_shentsize;</span><br></pre></td></tr></table></figure><p>要获得每个节头的地址需要用节头表指针加上index与节头大小的乘积。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shdr &#x3D; (Elf32_Shdr *)((char *)sh_table + (i * sh_entry_size));</span><br></pre></td></tr></table></figure><h5 id="补全kernel-lds文件"><a href="#补全kernel-lds文件" class="headerlink" title="补全kernel.lds文件"></a>补全kernel.lds文件</h5><p>根据教程格式写即可，注意内核的位置。</p><h5 id="init-start-S文件补全"><a href="#init-start-S文件补全" class="headerlink" title="init/start.S文件补全"></a>init/start.S文件补全</h5><p>将栈指针指向kernelbase，跳转到mips_init函数即可。</p><h5 id="完成vprintfmt-函数"><a href="#完成vprintfmt-函数" class="headerlink" title="完成vprintfmt()函数"></a>完成vprintfmt()函数</h5><p>由于vprintfmt()函数的实现方法有很多种，所以在完成这一部分时可以不按照教程代码注释的指引来写。需要注意的是循环的break条件，遇见’\0’需要跳出循环，不然会陷入死循环。还需要注意实现解析各个符号的含义，按照教程来即可。</p><h4 id="三、实验体会"><a href="#三、实验体会" class="headerlink" title="三、实验体会"></a>三、实验体会</h4><p>本次实验总体而言难度不大，但由于教程写的比较难懂，所以需要多耗费一些时间在教程的阅读和理解上面。同时也需要注意一些细节，容易在细节上出错。</p>]]></content>
      
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA_OO_hw1</title>
      <link href="/2024/03/11/BUAA-OO-hw1/"/>
      <url>/2024/03/11/BUAA-OO-hw1/</url>
      
        <content type="html"><![CDATA[<h3 id="BUAA-OO-hw1"><a href="#BUAA-OO-hw1" class="headerlink" title="BUAA_OO_hw1"></a>BUAA_OO_hw1</h3><p>架构图如下：</p><p><img src="hw_1.png" alt=""></p><h4 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h4><p>创建Processor类对输入的表达式进行预处理，去除空格、合并符号、将乘方拆分为多个x相乘的形式(例如：<em>x^3</em>  → x <em> x </em> x)</p><h4 id="expr包设计"><a href="#expr包设计" class="headerlink" title="expr包设计"></a>expr包设计</h4><p><img src="expr.png" alt=""></p><h5 id="Factor"><a href="#Factor" class="headerlink" title="Factor"></a>Factor</h5><p>本次作业因子分为两种: Number和Varible。为了方便后续的表达式运算，我根据因子计算的性质在其中设计了一个Hashmap来存储其指数和系数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Number &#123;</span><br><span class="line">    </span><br><span class="line">    private HashMap&lt;Integer, BigInteger&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    public HashMap&lt;Integer, BigInteger&gt; getMap() &#123;</span><br><span class="line">        return map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Var &#123;</span><br><span class="line"></span><br><span class="line">    private final HashMap&lt;Integer, BigInteger&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public HashMap&lt;Integer, BigInteger&gt; getMap() &#123;</span><br><span class="line">        return map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Term"><a href="#Term" class="headerlink" title="Term"></a>Term</h5><p>Term由Factor相乘得到，因此也使用Hashmap存储其指数和系数，同时为了乘法计算，使用mergeFactor()方法对Factor的乘法运算进行处理。</p><p>形式:</p><script type="math/tex; mode=display">a*x^b</script><h5 id="Expr"><a href="#Expr" class="headerlink" title="Expr"></a>Expr</h5><p>Expr由Term相加得到，也使用Hashmap存储每个Term的指数和系数，增加mergeTerm()方法对Term的加法进行处理。</p><p>形式:</p><script type="math/tex; mode=display">\sum_{i=1}^na_i*x_i^b</script><h4 id="递归下降"><a href="#递归下降" class="headerlink" title="递归下降"></a>递归下降</h4><p>按照训练给出的架构来做就好了：</p><h5 id="Lexer"><a href="#Lexer" class="headerlink" title="Lexer"></a>Lexer</h5><p>将processor处理后的表达式输入到Lexer中，Lexer通过next()方法解析表达式，再通过peek()方法将解析出的”词”传入Parser中。</p><h5 id="Parser"><a href="#Parser" class="headerlink" title="Parser"></a>Parser</h5><p>对Lexer传出的curToken在进行分析，运用parseExpr()方法获得Expr、parseTerm()获得Term、parseFactor()获得Factor。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>由于本次作业表达式形式相对简单，所以我也采用了Hashmap这种简单的方法进行处理。好处就是加减乘除计算处理非常简单，不需要递归。坏处就是可拓展性极差，只适用于第一次作业这种特定形式的表达式，因此在后续迭代中需要进行重构。</p>]]></content>
      
      
      
        <tags>
            
            <tag> OO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA_OS_Lab0</title>
      <link href="/2024/03/11/BUAA-OS-Lab0/"/>
      <url>/2024/03/11/BUAA-OS-Lab0/</url>
      
        <content type="html"><![CDATA[<h3 id="BUAA-OS-Lab0"><a href="#BUAA-OS-Lab0" class="headerlink" title="BUAA_OS_Lab0"></a>BUAA_OS_Lab0</h3><h4 id="一、实验思考题"><a href="#一、实验思考题" class="headerlink" title="一、实验思考题"></a>一、实验思考题</h4><h5 id="Thinking-0-1"><a href="#Thinking-0-1" class="headerlink" title="Thinking 0.1"></a>Thinking 0.1</h5><ul><li><p>执行cat Untracked.txt后的结果：README.txt文件位于untracked区</p><p><img src="/2024/03/11/BUAA-OS-Lab0/cat_Untracked.png" alt="cat_untracked"></p></li><li><p>执行cat Stage.txt后的结果：README.txt文件位于staged区</p><p><img src="/2024/03/11/BUAA-OS-Lab0/cat_stage.png"></p></li><li><p>修改修改README.txt 文件，再执行命令git status &gt; Modified.txt。执行命令cat Modified.txt后的结果：</p><p><img src="/2024/03/11/BUAA-OS-Lab0/modified.png"></p></li></ul><p>结果和第一次执行 add 命令之前的 status 不一样。第一次执行 add 命令之前的README.txt的 status是未跟踪，修改后的status是未暂存以备提交的变更</p><p>原因是执行add命令前README.txt未被跟踪，后续执行add命令文件被跟踪修改后未提交，所以处于未暂存状态。</p><h5 id="Thinking-0-2"><a href="#Thinking-0-2" class="headerlink" title="Thinking 0.2"></a>Thinking 0.2</h5><blockquote><p>Thinking0.2 仔细看看0.10，思考一下箭头中的add thefile、stage thefile和 commit分别对应的是Git里的哪些命令呢？</p></blockquote><p><img src="/2024/03/11/BUAA-OS-Lab0/status.png"></p><p>add the file 对应指令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add</span><br></pre></td></tr></table></figure><p>stage the file 对应指令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add</span><br></pre></td></tr></table></figure><p>commit 对应指令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit</span><br></pre></td></tr></table></figure><h5 id="Thinking-0-3"><a href="#Thinking-0-3" class="headerlink" title="Thinking 0.3"></a>Thinking 0.3</h5><p><img src="/2024/03/11/BUAA-OS-Lab0/git_structure.png"></p><blockquote><p>1、代码文件print.c 被错误删除时，应当使用什么命令将其恢复？</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- print.c</span><br></pre></td></tr></table></figure><blockquote><p>2、代码文件 print.c 被错误删除后，执行了 git rm print.c 命令，此时应当 使用什么命令将其恢复？</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout HEAD print.c</span><br></pre></td></tr></table></figure><blockquote><p>3、无关文件 hello.txt 已经被添加到暂存区时，如何在不删除此文件的前提下将其移出暂存区？</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD hello.txt</span><br></pre></td></tr></table></figure><h5 id="Thinking-0-4"><a href="#Thinking-0-4" class="headerlink" title="Thinking 0.4"></a>Thinking 0.4</h5><ul><li><p>在文件里加入Testing 1，git add，git commit，提交说明记为1。模仿上述做法，把1分别改为2和3，再提交两次。<img src="/2024/03/11/BUAA-OS-Lab0/4_add.png"></p></li><li><p>使用git log命令查看提交日志，看是否已经有三次提交，记下提交说明为3的哈希值。</p><p><img src="/2024/03/11/BUAA-OS-Lab0/log_1.png"></p></li><li><p>进行版本回退。执行命令git reset –hard HEAD^后，再执行git log，观 察其变化。</p><p><img src="/2024/03/11/BUAA-OS-Lab0/log_2.png"></p></li><li><p>找到提交说明为1的哈希值，执行命令git reset –hard后，再执 行git log，观察其变化。</p><p><img src="/2024/03/11/BUAA-OS-Lab0/log_3.png"></p></li><li><p>现在已经回到了旧版本，为了再次回到新版本，执行git reset –hard ，再执行git log，观察其变化。</p><p><img src="/2024/03/11/BUAA-OS-Lab0/log_4.png"></p></li></ul><h5 id="Thinking-0-5"><a href="#Thinking-0-5" class="headerlink" title="Thinking 0.5"></a>Thinking 0.5</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo first</span><br></pre></td></tr></table></figure><p><img src="/2024/03/11/BUAA-OS-Lab0/echo_1.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo second &gt; output.txt</span><br></pre></td></tr></table></figure><p><img src="/2024/03/11/BUAA-OS-Lab0/echo_2.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo third &gt; output.txt</span><br></pre></td></tr></table></figure><p><img src="/2024/03/11/BUAA-OS-Lab0/echo_3.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo forth &gt;&gt; output.txt</span><br></pre></td></tr></table></figure><p><img src="/2024/03/11/BUAA-OS-Lab0/echo_4.png"></p><h5 id="Thinking-0-6"><a href="#Thinking-0-6" class="headerlink" title="Thinking 0.6"></a>Thinking 0.6</h5><p>command文件内容：</p><p><img src="/2024/03/11/BUAA-OS-Lab0/command.png"></p><p>result文件内容：</p><p><img src="/2024/03/11/BUAA-OS-Lab0/result.png"></p><p>test文件命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo ...</span><br></pre></td></tr></table></figure><p>将…中的内容输出到result中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a&#x3D;1</span><br><span class="line">b&#x3D;2</span><br><span class="line">c&#x3D;$[$a+$b]</span><br></pre></td></tr></table></figure><p>将a赋值为1，b赋值为2，c赋值为3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo $c&gt;file1</span><br><span class="line">echo $b&gt;file2</span><br><span class="line">echo $a&gt;file3</span><br></pre></td></tr></table></figure><p>将a输出到为file3，c输出到为file1，b输出到为file2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat file1&gt;file4</span><br><span class="line">cat file2&gt;&gt;file4</span><br><span class="line">cat file3&gt;&gt;file4</span><br><span class="line">cat file4&gt;&gt;result</span><br></pre></td></tr></table></figure><p>将file1 file2 file3的值依次输出到file4中，再将file4的值输出到result尾部。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo echo Shell Start</span><br><span class="line">echo &#39;echo Shell Start&#39;</span><br></pre></td></tr></table></figure><p>效果无区别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo echo $c&gt;file1</span><br><span class="line">echo ’echo $c&gt;file1‘</span><br></pre></td></tr></table></figure><p>效果有区别，上面的输出结果为echo，下面输出结果为echo $c&gt;file1</p><h4 id="二、实验难点分析"><a href="#二、实验难点分析" class="headerlink" title="二、实验难点分析"></a>二、实验难点分析</h4><h5 id="bash脚本编写"><a href="#bash脚本编写" class="headerlink" title="bash脚本编写"></a>bash脚本编写</h5><p>[sed指令的使用]</p><blockquote><p>在src&#x2F;sh_test 目录下，有一个file 文件和hello_os.sh 文件。hello_os.sh 是 一个未完成的脚本文档，请同学们借助shell编程的知识，将其补完，以实现通过命令bash hello_os.sh AAA BBB，在 hello_os.sh 所处的目录新建一个名为 BBB 的文件，其内容为AAA文件的第8、32、128、512、1024行的内容提取(AAA文件行数一定超过1024行)。[注 意：对于命令bashhello_os.sh AAABBB，AAA及BBB可为任何合法文件的名称，例如 bashhello_os.sh filehello_os.c，若已有hello_os.c文件，则将其原有内容覆盖]</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">sed -n &#39;8p, 32p, 128p, 512p, 1024p&#39; $1 &gt; $2</span><br></pre></td></tr></table></figure><p>使用sed指令将参数$1文件中指定行输出到$2中</p><blockquote><p>在Lab0工作区的csc&#x2F;code目录下，存在fibo.c、main.c，其中fibo.c有点小 问题，还有一个未补全的modify.sh文件，将其补完，以实现通过命令bash modify.sh fibo.c char int，可以将fibo.c中所有的char字符串更改为int字符串。[注意：对于 命令bashmodify.sh fibo.ccharint，fibo.c可为任何合法文件名，char及int可 以是任何字符串，评测时评测modify.sh的正确性，而不是检查修改后fibo.c的正确性]</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">sed -i &quot;s&#x2F;$2&#x2F;$3&#x2F;g&quot; $1</span><br></pre></td></tr></table></figure><p>[循环语句的使用]</p><blockquote><p>在Lab0工作区ray&#x2F;sh_test1目录中，含有100个子目录file1<del>file100，还存 在一个名为changefile.sh的文件，将其补完，以实现通过命令bashchangefile.sh，可 以删除该目录内file71</del>file100共计30个子目录，将file41<del>file70共计30个子目录 重命名为newfile41</del>newfile70。[注意：评测时仅检测changefile.sh的正确性]</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">a&#x3D;1</span><br><span class="line">while [ $a -le 100 ]</span><br><span class="line">do</span><br><span class="line">if [ $a -gt 70 ]</span><br><span class="line">then</span><br><span class="line">rm -r file$a</span><br><span class="line">elif [ $a -gt 40 ]</span><br><span class="line">then</span><br><span class="line">mv file$a newfile$a</span><br><span class="line">fi</span><br><span class="line">a&#x3D;$((a+1))</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>[grep和awk指令的使用 重定向和管道的运用]</p><blockquote><p>在Lab0工作区的ray&#x2F;sh_test2目录下，存在一个未补全的search.sh文件， 将其补完，以实现通过命令bash search.sh file int result，可以在当前目录下生成 result文件，内容为file文件含有int字符串所在的行数，即若有多行含有int字符串 需要全部输出。[注意：对于命令bashsearch.sh file int result，file及result可 为任何合法文件名称，int可为任何合法字符串，若已有result文件，则将其原有内容覆 盖，匹配时大小写不忽略]</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">grep -n $2 $1 | awk -F : &#39;&#123;prin $1&#125;&#39; &gt; $3</span><br></pre></td></tr></table></figure><h5 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h5><blockquote><p>补全后的palindrome.c、Makefile、hello_os.sh依次复制到路径dst&#x2F;palindrome.c, dst&#x2F;Makefile,dst&#x2F;sh_test&#x2F;hello_os.sh[注意：文件名和路径必须与题目要求相同]</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mv palindrome.c ..&#x2F;dst</span><br><span class="line">mv Makefile ..&#x2F;dst</span><br><span class="line">mv hello_os.sh ..&#x2F;dst&#x2F;sh_test</span><br></pre></td></tr></table></figure><h5 id="Makefile编写"><a href="#Makefile编写" class="headerlink" title="Makefile编写"></a>Makefile编写</h5><blockquote><p>Lab0工作区的csc&#x2F;code&#x2F;fibo.c成功更换字段后(bashmodify.shfibo.cchar int)，现已有csc&#x2F;Makefile和csc&#x2F;code&#x2F;Makefile，补全两个Makefile文件，要求在 csc目录下通过命令make可在csc&#x2F;code目录中生成fibo.o、main.o，在csc目录中生 成可执行文件fibo，再输入命令makeclean后只删除两个.o文件。[注意：不能修改 fibo.h和main.c文件中的内容，提交的文件中fibo.c必须是修改后正确的fibo.c，可 执行文件fibo作用是输入一个整数n(从stdin输入n)，可以输出斐波那契数列前n项， 每一项之间用空格分开。比如n&#x3D;5，输出11235]</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">all: fibo                                                            </span><br><span class="line">fibo: code&#x2F;fibo.o code&#x2F;main.o</span><br><span class="line">gcc -o fibo code&#x2F;fibo.o code&#x2F;main.o</span><br><span class="line">code&#x2F;fibo.o: code&#x2F;fibo.c</span><br><span class="line">gcc -c code&#x2F;fibo.c -o code&#x2F;fibo.o -I include</span><br><span class="line">code&#x2F;main.o: code&#x2F;main.c</span><br><span class="line">gcc -c code&#x2F;main.c -o code&#x2F;main.o -I include</span><br><span class="line">clean:</span><br><span class="line">rm -r code&#x2F;main.o code&#x2F;fibo.o</span><br></pre></td></tr></table></figure><h4 id="三、实验体会"><a href="#三、实验体会" class="headerlink" title="三、实验体会"></a>三、实验体会</h4><p>由于上机前没有仔细看教程，导致对Linux一些指令用法的不熟悉、对Makefile和bash脚本写法不熟悉。这也导致了我在上机时写的很慢。在仔细阅读教程后，终于对自己犯的一些错误恍然大悟，对git、Linux命令、bash脚本编写和Makefile编写有了进一步的认识。总体而言，本次实验难度不大，主要是考察我们对基础知识的理解。</p>]]></content>
      
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello world</title>
      <link href="/2024/03/11/Hello-world/"/>
      <url>/2024/03/11/Hello-world/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
