<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>BUAA_OO_hw1</title>
      <link href="/2024/03/11/BUAA-OO-hw1/"/>
      <url>/2024/03/11/BUAA-OO-hw1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> OO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA_OS_Lab0</title>
      <link href="/2024/03/11/BUAA-OS-Lab0/"/>
      <url>/2024/03/11/BUAA-OS-Lab0/</url>
      
        <content type="html"><![CDATA[<h3 id="BUAA-OS-Lab0"><a href="#BUAA-OS-Lab0" class="headerlink" title="BUAA_OS_Lab0"></a>BUAA_OS_Lab0</h3><h4 id="一、实验思考题"><a href="#一、实验思考题" class="headerlink" title="一、实验思考题"></a>一、实验思考题</h4><h5 id="Thinking-0-1"><a href="#Thinking-0-1" class="headerlink" title="Thinking 0.1"></a>Thinking 0.1</h5><ul><li><p>执行cat Untracked.txt后的结果：README.txt文件位于untracked区</p><p><img src="/2024/03/11/BUAA-OS-Lab0/cat_Untracked.png" alt="cat_untracked"></p></li><li><p>执行cat Stage.txt后的结果：README.txt文件位于staged区</p><p><img src="/2024/03/11/BUAA-OS-Lab0/cat_stage.png"></p></li><li><p>修改修改README.txt 文件，再执行命令git status &gt; Modified.txt。执行命令cat Modified.txt后的结果：</p><p><img src="/2024/03/11/BUAA-OS-Lab0/modified.png"></p></li></ul><p>结果和第一次执行 add 命令之前的 status 不一样。第一次执行 add 命令之前的README.txt的 status是未跟踪，修改后的status是未暂存以备提交的变更</p><p>原因是执行add命令前README.txt未被跟踪，后续执行add命令文件被跟踪修改后未提交，所以处于未暂存状态。</p><h5 id="Thinking-0-2"><a href="#Thinking-0-2" class="headerlink" title="Thinking 0.2"></a>Thinking 0.2</h5><blockquote><p>Thinking0.2 仔细看看0.10，思考一下箭头中的add thefile、stage thefile和 commit分别对应的是Git里的哪些命令呢？</p></blockquote><p><img src="/2024/03/11/BUAA-OS-Lab0/status.png"></p><p>add the file 对应指令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add</span><br></pre></td></tr></table></figure><p>stage the file 对应指令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add</span><br></pre></td></tr></table></figure><p>commit 对应指令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit</span><br></pre></td></tr></table></figure><h5 id="Thinking-0-3"><a href="#Thinking-0-3" class="headerlink" title="Thinking 0.3"></a>Thinking 0.3</h5><p><img src="/2024/03/11/BUAA-OS-Lab0/git_structure.png"></p><blockquote><p>1、代码文件print.c 被错误删除时，应当使用什么命令将其恢复？</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- print.c</span><br></pre></td></tr></table></figure><blockquote><p>2、代码文件 print.c 被错误删除后，执行了 git rm print.c 命令，此时应当 使用什么命令将其恢复？</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout HEAD print.c</span><br></pre></td></tr></table></figure><blockquote><p>3、无关文件 hello.txt 已经被添加到暂存区时，如何在不删除此文件的前提下将其移出暂存区？</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD hello.txt</span><br></pre></td></tr></table></figure><h5 id="Thinking-0-4"><a href="#Thinking-0-4" class="headerlink" title="Thinking 0.4"></a>Thinking 0.4</h5><ul><li><p>在文件里加入Testing 1，git add，git commit，提交说明记为1。模仿上述做法，把1分别改为2和3，再提交两次。<img src="/2024/03/11/BUAA-OS-Lab0/4_add.png"></p></li><li><p>使用git log命令查看提交日志，看是否已经有三次提交，记下提交说明为3的哈希值。</p><p><img src="/2024/03/11/BUAA-OS-Lab0/log_1.png"></p></li><li><p>进行版本回退。执行命令git reset –hard HEAD^后，再执行git log，观 察其变化。</p><p><img src="/2024/03/11/BUAA-OS-Lab0/log_2.png"></p></li><li><p>找到提交说明为1的哈希值，执行命令git reset –hard后，再执 行git log，观察其变化。</p><p><img src="/2024/03/11/BUAA-OS-Lab0/log_3.png"></p></li><li><p>现在已经回到了旧版本，为了再次回到新版本，执行git reset –hard ，再执行git log，观察其变化。</p><p><img src="/2024/03/11/BUAA-OS-Lab0/log_4.png"></p></li></ul><h5 id="Thinking-0-5"><a href="#Thinking-0-5" class="headerlink" title="Thinking 0.5"></a>Thinking 0.5</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo first</span><br></pre></td></tr></table></figure><p><img src="/2024/03/11/BUAA-OS-Lab0/echo_1.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo second &gt; output.txt</span><br></pre></td></tr></table></figure><p><img src="/2024/03/11/BUAA-OS-Lab0/echo_2.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo third &gt; output.txt</span><br></pre></td></tr></table></figure><p><img src="/2024/03/11/BUAA-OS-Lab0/echo_3.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo forth &gt;&gt; output.txt</span><br></pre></td></tr></table></figure><p><img src="/2024/03/11/BUAA-OS-Lab0/echo_4.png"></p><h5 id="Thinking-0-6"><a href="#Thinking-0-6" class="headerlink" title="Thinking 0.6"></a>Thinking 0.6</h5><p>command文件内容：</p><p><img src="/2024/03/11/BUAA-OS-Lab0/command.png"></p><p>result文件内容：</p><p><img src="/2024/03/11/BUAA-OS-Lab0/result.png"></p><p>test文件命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo ...</span><br></pre></td></tr></table></figure><p>将…中的内容输出到result中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a&#x3D;1</span><br><span class="line">b&#x3D;2</span><br><span class="line">c&#x3D;$[$a+$b]</span><br></pre></td></tr></table></figure><p>将a赋值为1，b赋值为2，c赋值为3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo $c&gt;file1</span><br><span class="line">echo $b&gt;file2</span><br><span class="line">echo $a&gt;file3</span><br></pre></td></tr></table></figure><p>将a输出到为file3，c输出到为file1，b输出到为file2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat file1&gt;file4</span><br><span class="line">cat file2&gt;&gt;file4</span><br><span class="line">cat file3&gt;&gt;file4</span><br><span class="line">cat file4&gt;&gt;result</span><br></pre></td></tr></table></figure><p>将file1 file2 file3的值依次输出到file4中，再将file4的值输出到result尾部。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo echo Shell Start</span><br><span class="line">echo &#39;echo Shell Start&#39;</span><br></pre></td></tr></table></figure><p>效果无区别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo echo $c&gt;file1</span><br><span class="line">echo ’echo $c&gt;file1‘</span><br></pre></td></tr></table></figure><p>效果有区别，上面的输出结果为echo，下面输出结果为echo $c&gt;file1</p><h4 id="二、实验难点分析"><a href="#二、实验难点分析" class="headerlink" title="二、实验难点分析"></a>二、实验难点分析</h4><h5 id="bash脚本编写"><a href="#bash脚本编写" class="headerlink" title="bash脚本编写"></a>bash脚本编写</h5><p>[sed指令的使用]</p><blockquote><p>在src&#x2F;sh_test 目录下，有一个file 文件和hello_os.sh 文件。hello_os.sh 是 一个未完成的脚本文档，请同学们借助shell编程的知识，将其补完，以实现通过命令bash hello_os.sh AAA BBB，在 hello_os.sh 所处的目录新建一个名为 BBB 的文件，其内容为AAA文件的第8、32、128、512、1024行的内容提取(AAA文件行数一定超过1024行)。[注 意：对于命令bashhello_os.sh AAABBB，AAA及BBB可为任何合法文件的名称，例如 bashhello_os.sh filehello_os.c，若已有hello_os.c文件，则将其原有内容覆盖]</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">sed -n &#39;8p, 32p, 128p, 512p, 1024p&#39; $1 &gt; $2</span><br></pre></td></tr></table></figure><p>使用sed指令将参数$1文件中指定行输出到$2中</p><blockquote><p>在Lab0工作区的csc&#x2F;code目录下，存在fibo.c、main.c，其中fibo.c有点小 问题，还有一个未补全的modify.sh文件，将其补完，以实现通过命令bash modify.sh fibo.c char int，可以将fibo.c中所有的char字符串更改为int字符串。[注意：对于 命令bashmodify.sh fibo.ccharint，fibo.c可为任何合法文件名，char及int可 以是任何字符串，评测时评测modify.sh的正确性，而不是检查修改后fibo.c的正确性]</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">sed -i &quot;s&#x2F;$2&#x2F;$3&#x2F;g&quot; $1</span><br></pre></td></tr></table></figure><p>[循环语句的使用]</p><blockquote><p>在Lab0工作区ray&#x2F;sh_test1目录中，含有100个子目录file1<del>file100，还存 在一个名为changefile.sh的文件，将其补完，以实现通过命令bashchangefile.sh，可 以删除该目录内file71</del>file100共计30个子目录，将file41<del>file70共计30个子目录 重命名为newfile41</del>newfile70。[注意：评测时仅检测changefile.sh的正确性]</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">a&#x3D;1</span><br><span class="line">while [ $a -le 100 ]</span><br><span class="line">do</span><br><span class="line">if [ $a -gt 70 ]</span><br><span class="line">then</span><br><span class="line">rm -r file$a</span><br><span class="line">elif [ $a -gt 40 ]</span><br><span class="line">then</span><br><span class="line">mv file$a newfile$a</span><br><span class="line">fi</span><br><span class="line">a&#x3D;$((a+1))</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>[grep和awk指令的使用 重定向和管道的运用]</p><blockquote><p>在Lab0工作区的ray&#x2F;sh_test2目录下，存在一个未补全的search.sh文件， 将其补完，以实现通过命令bash search.sh file int result，可以在当前目录下生成 result文件，内容为file文件含有int字符串所在的行数，即若有多行含有int字符串 需要全部输出。[注意：对于命令bashsearch.sh file int result，file及result可 为任何合法文件名称，int可为任何合法字符串，若已有result文件，则将其原有内容覆 盖，匹配时大小写不忽略]</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">grep -n $2 $1 | awk -F : &#39;&#123;prin $1&#125;&#39; &gt; $3</span><br></pre></td></tr></table></figure><h5 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h5><blockquote><p>补全后的palindrome.c、Makefile、hello_os.sh依次复制到路径dst&#x2F;palindrome.c, dst&#x2F;Makefile,dst&#x2F;sh_test&#x2F;hello_os.sh[注意：文件名和路径必须与题目要求相同]</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mv palindrome.c ..&#x2F;dst</span><br><span class="line">mv Makefile ..&#x2F;dst</span><br><span class="line">mv hello_os.sh ..&#x2F;dst&#x2F;sh_test</span><br></pre></td></tr></table></figure><h5 id="Makefile编写"><a href="#Makefile编写" class="headerlink" title="Makefile编写"></a>Makefile编写</h5><blockquote><p>Lab0工作区的csc&#x2F;code&#x2F;fibo.c成功更换字段后(bashmodify.shfibo.cchar int)，现已有csc&#x2F;Makefile和csc&#x2F;code&#x2F;Makefile，补全两个Makefile文件，要求在 csc目录下通过命令make可在csc&#x2F;code目录中生成fibo.o、main.o，在csc目录中生 成可执行文件fibo，再输入命令makeclean后只删除两个.o文件。[注意：不能修改 fibo.h和main.c文件中的内容，提交的文件中fibo.c必须是修改后正确的fibo.c，可 执行文件fibo作用是输入一个整数n(从stdin输入n)，可以输出斐波那契数列前n项， 每一项之间用空格分开。比如n&#x3D;5，输出11235]</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">all: fibo                                                            </span><br><span class="line">fibo: code&#x2F;fibo.o code&#x2F;main.o</span><br><span class="line">gcc -o fibo code&#x2F;fibo.o code&#x2F;main.o</span><br><span class="line">code&#x2F;fibo.o: code&#x2F;fibo.c</span><br><span class="line">gcc -c code&#x2F;fibo.c -o code&#x2F;fibo.o -I include</span><br><span class="line">code&#x2F;main.o: code&#x2F;main.c</span><br><span class="line">gcc -c code&#x2F;main.c -o code&#x2F;main.o -I include</span><br><span class="line">clean:</span><br><span class="line">rm -r code&#x2F;main.o code&#x2F;fibo.o</span><br></pre></td></tr></table></figure><h4 id="三、实验体会"><a href="#三、实验体会" class="headerlink" title="三、实验体会"></a>三、实验体会</h4><p>由于上机前没有仔细看教程，导致对Linux一些指令用法的不熟悉、对Makefile和bash脚本写法不熟悉。这也导致了我在上机时写的很慢。在仔细阅读教程后，终于对自己犯的一些错误恍然大悟，对git、Linux命令、bash脚本编写和Makefile编写有了进一步的认识。总体而言，本次实验难度不大，主要是考察我们对基础知识的理解。</p>]]></content>
      
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello world</title>
      <link href="/2024/03/11/Hello-world/"/>
      <url>/2024/03/11/Hello-world/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
